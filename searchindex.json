{"categories":[{"title":"CG","uri":"https://jaylanwood.github.io/categories/cg/"},{"title":"前端","uri":"https://jaylanwood.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"title":"搭博客","uri":"https://jaylanwood.github.io/categories/%E6%90%AD%E5%8D%9A%E5%AE%A2/"}],"posts":[{"content":"简介 这篇文章只是我这样一个爱好者写的，不是给技术大佬看的，所以有不对的地方请指正请轻喷，当然，有大佬指正小弟巴不得呢！\n作者：JaylanWood\n联系作者：jaylanwu@outlook.com\n转载需声明来源。\n开头上道硬菜 个人认为，看懂这个图是最关键的，它描述了金属和非金属的反射值的变化。\n金属还是非金属 这有个diffuse问题 纯金属没有 diffuse，有 diffuse 的都是有杂质。\n来，做金属\n给做个纯金，你看这个24K纯金球又大又圆。\n只有 glossy 做能量贡献。\n来，做非金属\n由 Fresnel 分配 diffuse 和 glossy 的能量贡献。\n来，给金属来点 diffuse 尝尝\n完了，这金做出全是杂质了，不值钱了！\n为什么呢\n看懂了吗？！看到金属里那个红色的叉了吗？金属根本没有 diffuse！\n引用龚大的话：\n 对于金属来说，diffuse永远是0，材质的颜色来自于 specular。对于非金属来说，材质的颜色一部分来自于diffuse，一部分来自于specular。\n 能量守恒（Energy Conservation） 散射（diffuse） + 反射（ glossy）\u0026lt;= 入射（光源）\n注意：Blender 的 glossy 在 vray 里是 Reflect，一个意思，就是镜面反射（Specular Reflection）。\n一时想不到怎么做个能量不守恒的材质，以后有机会再写这个。\n引用《THE PBR GUIDE - PART 1》\n 能量守恒在PBR渲染中起到至关重要的作用。这个原则认为一个表面二次发射（反射或散射）的光必须少于这个表面接收到的光。换句话说，从表面反射的光将永远不会比入射到表面之前更强烈。\n 英文原文：\n Energy conservation plays a vital role in physically-based rendering solutions. This principle states the total amount of light re-emitted by a surface (reflected and scattered back) is less than the total amount received. In other words, the light reflected from the surface will never be more intense than it was before it hit the surface.\n Fresnel 和 F0 反射值随着光线与物体法线的夹角变化而变化，夹角从0到90度，非金属物体反射值从 0.02-0.05 到 1，金属物体反射指从 0.5-0.9 到 1。\n1.Everything has Fresnel 来看看 Frenel 到底是怎么回事\n用 Emission 来展示 Frenel 是怎么表达从 F0 到 F90（好像没F90这说法，反正我就这么叫了）\nF0 到 F90，由黑到白，这里展示了 IOR 是1.45 的 Fresnel 反射强度变化（只不过这里是用自发光Emission来展示，以免收到其他灯光影响）\n来看看非金属没有 Fresnel 会怎么样\nOh, shit! 所有角度的 Glossy 都一样强。\n于是，很多人将错就错做出了下面这样的错误材质\n什么？你说你没发现错在哪里？也没见过这种错误的做法？来看看 vray 版？\n看看那些风骚的错误操作：\n 把 Fresnel 关掉。 关掉也就算了，也不见在 Reflect 里把 Fresnel 反射曲线给弄出来。 把 Reflect 降低，看起来好像做对了，实际上已经错了。所有角度的反射值都统一降低了。  不知道什么是 Fresnel 反射曲线？看图\n看到起始点在 0.9 以上的吗？那是大部分金属的反射变化。\n看见起始点在 0.2 左右的吗？那是钻石，知道为啥它能闪瞎钛合金狗眼了吗。\n看到起始点在 0.05 以下的吗？那是非金属的反射变化。\n题外话：知道为啥 substance 要把非金属 F0 设置为 0.04 了吗？！\n还看不出来问题？没有对比就没有伤害！\n不管是金属还是非金属，都是有 Fresnel，记住：\nEverything has Fresnel\n当然，跟随角度变化而变化的，不止反射强度，还有反射模糊，为了好理解，这里就不展开说了。\n2.那么F0是怎么算出来的呢 上公式：\n公式里的 n 是 IOR，知道 vray 的 IOR 咋回事了吧。\n代入水的IOR=1.33，得到F0是0.02：\n金属度（metalness） 1.金属度是个啥？物理书上有写？我读书少，你别骗我！ 好好好，不骗你，物理书确实没写金属度，来看看技术大佬们是怎么说的：\nUNDERSTANDING METALNESS 中 Christopher Nichols 访问 Autodesk 着色器技术专家 Zap Andersson 的音频片段翻译，采访音频时间长达1:08:32，从39分开始讨论到金属度。\n译者：JaylanWood\n译文：\n Christopher Nichols：在现实世界中，没有东西既是金属又是非金属的，对吧？\nZap Andersson：没错。意图是，当你使用此功能时，实际上是要更多地将金属度（metalness）这个参数当作是遮罩（mask）来使用，仅此而已。\nChristopher Nichols：当作遮罩，是吗？\nChristopher Nichols：所以，（金属度）那些中间值存在的理由是为了抗锯齿（aliasing）？\nZap Andersson：基本上是的，仅此而已。\nChristopher Nichols：所以它是金属和非金属的遮罩。\nZap Andersson：我的意思是，举个例子。比如说 substance painter，做一把战斧，它是一个一体的模型，上面只有一种材质，所有东西都在纹理中。因此，战斧的手柄是木头材质，战斧的斧头是金属材质。所以斧头上的金属度是1，手柄上的金属度是0。那么在它们衔接之间的一些抗锯齿像素中可能是0.5。\nChristopher Nichols：对。\nZap Andersson：这就是正确的使用方式。\nChristopher Nichols：但是人们不一定理解这一点。\nZap Andersson: 确实可能是这样的。有的人调一个0.35金属度，还指望它是科学的，但事实并非如此。\nChristopher Nichols：确实不科学。\nZap Andersson：绝对不是。\n 抗锯齿和遮罩的说法确实是很新奇，从图像角度解释了金属度中间值。\n2.金属度并不是一个完全的物理学上的东西 来看看《The PBR Guide》对金属度贴图的描述:\nFigure 26: Base color map contains reflectance values for raw metal as indicated by the metal map\n 金属贴图中并没有包含直接被材质引用的真实世界的数据（如反照率颜色、反射值等），它只是比较简单地对着色器描述Base Color中的哪个区域应该被解析成反照率颜色（非导体），哪个区域应该被描述成金属的反射值。\n在金属贴图中，0.0（纯黑-0sRGB）代表了非金属，而1.0（纯白-255sRGB）代表了原始金属。当金属贴图被用于定义原始金属与非金属时，一般都是二态的：纯黑或纯白，意味着材质除了原始金属就是非金属。在实现过程中，当着色器监测到金属贴图中的白色区域时，它会检查 Base Color 贴图中相应的位置来获取金属的反射值并进行渲染（如图26）。\n 事实上，PBR 把 diffuse 和 Specular Reflection 2个通道合成一个 Base color 通道。\n 当一个材质是纯非金属材质时候，固有色（Base color）是漫反射率（Diffuse），镜面反射率不做说明的话是固定值。 当一个材质是纯金属材质时候，固有色（Base color）是镜面反射率（Specular Reflection），漫反射率是0。 当一个材质处于以上两者之间时，固有色（Base color）会同时影响两个反射率（Diffuse 和 Specular Reflection）。  为啥这样做？\n因为纯金属不需要diffuse。\n纯非金属固定镜面反射率（Specular Reflection）从 F0的0.04 到 F90的1，只需要diffuse就行。\n3.金属度说得笼统点，不就是 F0、Fresnel 的简化。 金属度更多的是传统 GGX BRDF 的简化，把非金属的 F0 写死 0.04，美术们就不会违反能量守恒了。\n金属度并不是一个完全的物理学上的东西，1是金属，0是非金属，0-1之间是半导体。日常生活中基本上没有半导体，但是铁锈材质贴图里的0-1之间的灰度又是怎么回事？\nsubstance 里生锈材质的金属度就是0-1之间的，生锈材质它算不上是半导体。不过从微观层面，铁锈确实是金属和非金属混在一起。\nsubstance《The PBR Guide》有专门提到生锈材质：\n  金属被氧化、腐蚀、上漆、覆尘后，这些区域需要被当做非导体（电介质）材质来看待。 在金属贴图中，纯黑（0.0）代表了非金属，纯白（1.0）代表了金属，我们可以用过渡的灰阶来表示不同程度氧化和污垢。 如果金属贴图中有值低于235 sRGB，那么在Base Color中对应区域的反射值也应该降低。   PBR 是传统 GGX BRDF 模型的简化限制版。\n精简\n把 F0、Fresnel 这些复杂的东西做成了金属度（metalness），美术人员按照原始金属1、非金属0、生锈0-1 去考虑金属度就能把材质分清楚了。\n限制\n在金属工作流（Metal/Roughness Workflow）里，默认把非金属的 F0 设置在 0.04，美术人员想改都改不了，彻底杜绝破坏能量守恒定律的可能，保证了PBR的基于物理。\n更省通道 更省内存\n把 漫反射和反射 合成 金属度，并且金属度是灰色贴图，从程序角度，不就是省了通道省了内存嘛，游戏流行 PBR 啊。\n为什么我觉得金属工作流是 PBR 的精髓 1.来看看金属工作流（Metal/Roughness Workflow） 优势\n 在金属工作流中，由于非导体（电介质）的F0都是规定好的，所以设计师在对非导体F0赋值时不易出错。 纹理的缓存压力更小，因为金属贴图和粗糙度贴图都是灰度贴图。 目前来说是兼容性最广的工作流。  劣势\n 非导体（电介质）F0 的值固定为4%，无法调整。然而，在大多是实现流程中都有控制器可以直接复写这个值，所以也不能算硬伤。 白色边缘问题较明显，尤其在低分辨率的情况下问题突出。  2.来看看镜面反射工作流（Specular/Glossiness Workflow） 优势\n 边缘效应不会那么明显。 可以在镜面反射贴图中对非导体（电介质）材质的F0值自由调整。  劣势\n 由于在镜面反射工作流的镜面反射贴图中，非导体（电介质）材质的 F0 值是可以自由调整的，所以也会导致设计师容易输入错误的值。而这些错误的值被着色器误读后可能会打破能量守恒定律，从而造成不正确的渲染效果。 由于新增了一张RGB通道的镜面反射贴图，所以对性能消耗会更大。 镜面反射工作流有些名词和传统的工作流太相似，但是实质所对应的数据可能是不一样的，因此会导致设计师容易误解或误操作。这种情况下就要求设计师有更好的PBR理论知识，例如了解非导体（电介质）的正确F0值，金属在漫反射色下表现为纯黑，以及在着色器没有自动校正情况下，能量守恒相关的基础知识。  3.为啥？因为镜面反射流可以乱调 F0 啊！ 因为镜面反射工作流（Specular/Glossiness Workflow）是可以调整 F0 的，就是 Specular 这个参数可以调 F0，调的不好就打破了能量守恒和 PBR。\n所以说，在 PBR 里用 Specular 工作流的人基本都是大神，他们能根据现实材质的需要把 0.02-0.05 之间这么细微的 F0 给准确测出来，他们不满足于锁死的 F0。\n为美好的 PBR 献上祝福 作为半吊子爱好者，学啥啥吃力，一直觉得传统 GGX BRDF 调个材质跟研究物理光学似的，一不小心看到别人在 vray 把 Fresnel 去勾，就觉得很难受。\n感谢 PBR 带来的方便，再也不怕脑子不够用了。为美好的 PBR 献上祝福！撒花！\n资料参考 金属，塑料，傻傻分不清楚\n作者：叛逆者\n简介：微软图形大神龚敏敏出品的文章，说得很透测。\nUNDERSTANDING METALNESS\n作者：Christopher Nichols\n简介：一篇来自 Chaos Group Labs 的主管 Christopher Nichols 的博客，在文章结尾还附有 Christopher Nichols 访问 Autodesk 着色器技术专家 Zap Andersson 的音频，时间长达1:08:32，从39分开始讨论到金属度。\nTHE PBR GUIDE - PART 1 和 THE PBR GUIDE - PART 2\n作者：Adobe Substance 官方\n简介：Adobe Substance 官方出品的 PBR 指导手册，可能是目前最好的 PBR 资料。\n","id":0,"section":"posts","summary":"简介 这篇文章只是我这样一个爱好者写的，不是给技术大佬看的，所以有不对的地方请指正请轻喷，当然，有大佬指正小弟巴不得呢！ 作者：JaylanWo","tags":["PBR","Fresnel","Metalness"],"title":"为美好的 PBR 献上祝福","uri":"https://jaylanwood.github.io/2020/04/%E4%B8%BA%E7%BE%8E%E5%A5%BD%E7%9A%84-pbr-%E7%8C%AE%E4%B8%8A%E7%A5%9D%E7%A6%8F/","year":"2020"},{"content":"为什么要HTML？ 最初的设计目的：\n李爵士需要同事电脑里数据，但是它们来自不同国家、不同电脑、不同种类的文档类型。于是他决定把标准化的文档放在一起，点击就能跳转文档。\n实现方式：\n1.超文本（hypertext）：点击跳转网页\n2.标记（markup）：注明文本、图片和其他内容\n示例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;This is a title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello world!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  谁实现了超文本？（hypertext） \u0026lt;a\u0026gt;标签，点击就能跳转另一个html文档。\n示例：\n\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/\u0026quot;\u0026gt;MDN官网\u0026lt;/a\u0026gt;  效果：\nMDN官网\n谁实现了标记？（markup） 标签（tag）\n示例：\n\u0026lt;p\u0026gt;为美好的网站\u0026lt;i\u0026gt;献上\u0026lt;/i\u0026gt;祝福\u0026lt;/p\u0026gt;  效果：\n为美好的网站献上祝福\n不想跳转怎么办？ 跳转html文档很麻烦，我想在当前页面就能看另一个html文档怎么办？\n\u0026lt;iframe\u0026gt;\n示例：\n\u0026lt;iframe id=\u0026quot;inlineFrameExample\u0026quot; title=\u0026quot;Inline Frame Example\u0026quot; width=\u0026quot;300\u0026quot; height=\u0026quot;200\u0026quot; src=\u0026quot;https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606\u0026amp;layer=mapnik\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt;  效果：\n 语义化 结构化 让html页面像一篇文章一样，有头有尾，有标题，有段落，有章节，让人类可读可写，让计算机知道怎么处理页面内容。\n\u0026lt;body\u0026gt; \u0026lt;header\u0026gt;页眉\u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h1\u0026gt;文章标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;文章内容\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt;页尾\u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt;  如果不语义化结构化的话\n\u0026lt;body\u0026gt; \u0026lt;span\u0026gt;结构化语义化就跟写文章一样，有头有尾有主体，有文章，有章节，有标题有段落。\u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt;不语义化结构化会怎样？人类看着乱，计算机看着也乱。\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;div和span使劲怼\u0026lt;/div\u0026gt; \u0026lt;span\u0026gt;你说乱不乱。\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;不乱？别光看网页啊\u0026lt;br\u0026gt;看html源码你就知道这写的都是什么乱七八糟的东西了。\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt;  ","id":1,"section":"posts","summary":"为什么要HTML？ 最初的设计目的： 李爵士需要同事电脑里数据，但是它们来自不同国家、不同电脑、不同种类的文档类型。于是他决定把标准化的文档放在","tags":["HTML"],"title":"LearnHTML","uri":"https://jaylanwood.github.io/2020/04/learnhtml/","year":"2020"},{"content":"说明 本文转载自掘金，写得非常好，适合让前端新手有一个全局性的理解和制定学习规划。\n作者：村口蹲一郎\n时间：2018/07/27\n原文：文章链接\n简介 本文适合前端新手入门，阅读人群最好是前端新手或者后台开发人员，因为我不敢保证对前端老司机有太多收获。\n通过阅读本文，你将会大致了解前端这些年发生的事情，以及一些前端当前主流技术的简单原理介绍。所有涉及的内容，都是尽可能的让你捅破这层窗户纸，知道其大致的玩法。\n目录  前端技术发展轨迹  角色架构发展史 前端技术发展史 ECMAScript语法发展史 Ajax技术发展史   当前主流技术原理介绍  SPA 单页面应用原理 Node.js 服务器端JS运行原理 SSR 服务器端渲染原理 Vue MVVM原理 Webpack 打包原理 Sass CSS编译原理   一些新技术探索  TypeScript PWA GraphQL Flutter   两个流行的概念解答  什么是大前端 什么是前端工程化    一、前端技术发展轨迹 本节知识点：\n 角色架构发展史 前端技术发展史 ECMAScript语法发展史 Ajax技术发展史  1.1 角色架构发展史 Web1.0 到 Web2.0过渡的标志，就是Ajax的出现（2005年）。\n1.2 前端技术发展史 1.3 ECMAScript语法发展史 1.4 Ajax技术发展史 AJAX 即 Asynchronous JavaScript and XML（异步的 JavaScript 与 XML 技术）。\nSTEP1：XMLHttpRequest 原生对象 var request = new XMLHttpRequest(); request.open('GET', '/my/url', true); request.onload = function() { if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 400) { // Success! var data = JSON.parse(request.responseText); } else { // We reached our target server, but it returned an error } }; request.onerror = function() { // There was a connection error of some sort }; request.send();  STEP2：$.ajax 操作 $.ajax({ type: 'GET', url: '/my/url', data: data, success : function(result){ //TODO RESULT } });  STEP3：Promise 操作 let getData = function (url) { return new Promsie(function (resolve, reject) { $.ajax({ type: 'GET', url: url, success: function (data) { resolve(data); }, error: function (err) { reject(err); } }); }); }; var data = getData('/my/url').then(function (data) { //TODO DATA });  STEP4：生成器 Gererator let it = null; let ajax = function(url,data){ $.ajax({ type: 'GET', url: url, data: data || {}, success : function(result){ it.next(result); } }); }; function *getData(){ var data = yield ajax('/my/url'); console.log('data=',data); }; it = getData(); it.next();  STEP5：Async/Await 高级操作 let ajax = function(url,data){ return $.ajax({ type: 'GET', url: url, data: data || {} }); }; async function getData(){ var data = await ajax('/my/url'); console.log('data=',data); }; getData();  Ajax的相关背景资料：\n 1999年，微软公司发布IE浏览器5.0版，第一次引入新功能：允许JavaScript脚本向服务器发起HTTP请求。这个功能当时并没有引起注意，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。\n2005年2月，AJAX这个词第一次正式提出，指围绕这个功能进行开发的一整套做法。从此，AJAX成为脚本发起HTTP通信的代名词，W3C也在2006年发布了它的国际标准。\n 二、当前主流技术原理介绍 本节知识点：\n SPA 单页面应用原理 Node.js 服务器端JS运行原理 SSR 服务器端渲染原理 Vue MVVM原理 Webpack 打包原理 Sass CSS开发原理  2.1 SPA 单页面应用原理 什么是SPA? SPA 即单页面，就是页面整体不刷新，不同的页面只改变局部的内容的一种实现方式。\n一个完整的URI有以下几部分组成：\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]  浏览器的URL也遵循以上规则，而对于以上规则中，只有 # 后面的 fragment 发生改变时，页面不会重新请求，其它参数变化，均会引起页面的重新请求，而在Js中恰恰还有事件 window.onhashchange 能监听到 fragment 的变化，于是就利用这个原理来达到一个修改局部内容的操作。\n#fragment 部分就是对应到Js中的 location.hash 的值。\n直接上代码描述：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; window.onhashchange = function(){ var page = location.hash; if(page === '#home'){ document.getElementById('main').innerHTML = '这是首页'; return; }; if(page === '#help'){ document.getElementById('main').innerHTML = '这是帮助页面'; return; }; document.getElementById('main').innerHTML = '404'; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;a href=\u0026quot;#home\u0026quot;\u0026gt;首页\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;#help\u0026quot;\u0026gt;帮助\u0026lt;/a\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;article id=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;/article\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  以上代码直接在HTML上面有2个链接，点击后在页面的部分区域直接显示这2个链接对应的不同的页面内容。\n2.2 Node.js 服务器端JS运行原理 服务器上如何应用Js呢？这句话可以理解为：在非网页情况下如何运行Js程序（或者命令行如何运行）。\n与Java在服务器上运行需要按照JDK一样，Js要运行也需要安装Node环境，安装以后就可以运行了，具体的可以对照着Java程序来解释说明。\n2.3 SSR 服务器端渲染原理 用过Java的人一定对 FreeMarker 不陌生，其工作原理：\n对于Node.js来说也是一样，只是使用的框架不是FreeMarker罢了！究其原理无非都是：\nTemplate + Data = Output  只是现在前端说的这个SSR，其实就是指后台渲染好数据，直接返回到浏览器，浏览器就直接显示了，下面我们做一个对比，用来说明传统的AJax操作和SSR之间的区别。\n使用Ajax操作数据渲染到页面 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;lib/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; /* * 使用jQuery将后台接口返回的数据显示到页面上 */ function renderData(){ $.post(url,param,function(result){ //假设返回的是是一个List，我们追加到页面的ul中 $.each(result,function(i,d){ $('#list').append('\u0026lt;li\u0026gt;' + d.name + '\u0026lt;/li\u0026gt;'); }) }); }; renderData(); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026quot;list\u0026quot;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  主要流程如下：\n 用户地址栏输入URL 浏览器使用HTTP协议从后台获取资源 浏览器解析并渲染HTML页面呈现到浏览器上，同时异步执行Ajax操作 浏览器发送Ajax请求后台接口 浏览器获取到数据后，执行回调函数，将内容动态追加到页面上  使用SSR技术显示页面 下面示例我们以Vue框架后台直出方案为例：\nconst Vue = require('vue') const server = require('express')() const renderer = require('vue-server-renderer').createRenderer() server.get('*', (req, res) =\u0026gt; { //vue对象包含了template+data const app = new Vue({ data: { list: [{ name : 'lilei' },{ name : 'hanmeimei' }] }, template: `\u0026lt;ul\u0026gt;\u0026lt;li v-for=\u0026quot;item in list\u0026quot;\u0026gt;{{item.name}}\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt;` }) //将vue对象传入最终返回output结果html //再将html通过reponse对象返回给前端浏览器 renderer.renderToString(app, (err, html) =\u0026gt; { res.end(` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt;${html}\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; `) }) }) server.listen(8080)  主要流程如下：\n 用户地址栏输入URL 浏览器使用HTTP协议从后台获取资源 浏览器解析并渲染HTML页面呈现到浏览器上  如果有人对这个vue示例的完整构建流程感兴趣，可以按照如下流程快速搭建环境并允许起来：\n 下载并安装Nodejs：https://nodejs.org/zh-cn/download/ 新建一个目录，打开命令窗口，切换到当前目录 执行命令：npm init，一直回车进行下一步，快速创建一个node工程 安装所需要的js包：npm i vue express vue-server-renderer \u0026ndash;save-dev 新建文件：vi index.js，将上面的vue代码片段全部粘贴进去 执行文件启动Node程序：node index.js 打开浏览器访问：http://localhost:8080（注意端口号不要跟本地已有程序冲突）  2.4 Vue MVVM原理 什么是MVC？什么是MVVM？\n通过上图可以清晰的看到，MVVM相比MVC来说，缺少了 Controller 一层，传统 Controller 做的事情就是处理一堆复杂的逻辑，然后将数据输出到 View 上面。那么现在缺少了这一层以后，View 和 ViewModel 之间如何进行双向自动关联数据绑定的呢？\n也就是说，页面上数据发生变化，Js中的数据如何跟着也变化；相反，Js中数据变化了，页面如何自动跟着变化？\n举个例子来进一步阐明这个问题，下面的效果如何实现？\n页面数据发生变化如何通知到JS 通过给页面元素添加 onchange 或者 oninput 事件，在事件中获取表单的值，然后赋值给Js对应的对象上即可。\n比如：示例中的输入框就可以添加oninput事件\n\u0026lt;input type=\u0026quot;text\u0026quot; oninput=\u0026quot;evtInput\u0026quot; /\u0026gt;  然后在js中定义这个函数执行相关赋值操作就可以：\nfunction evtInput(){ vue.name = this.value; }  JS数据变化如何通知到页面 JavaScript原生有个方法 Object.defineProperty() ，这个方法可以重新设置一个js对象中某个元素的一些属性，同时提供了 get 和 set 方法，允许用户对元素进行重新赋值和取值操作。\n简单分析一下代码：\n正式由于我们可以通过拦截一个属性的 set 方法。所以，我们就可以在 set 方法中讲获取到的新值赋值给页面元素就可以了。\nObject.defineProperty(data,'name',{ set : function(v){ document.getElementById('input').value = v; } });  2.5 Webpack 打包原理 前端为什么要打包？ 那么前端为什么要进行打包呢？前端代码不是直接就能运行到浏览器么，还打包干嘛？\n要搞清楚这个问题，那么我们就以java为例可能比较恰当，比如：java的工程目录中有一个源码目录：src\n它是用来存放java源码的，但是java实际编译后肯定就没有src这个目录了对吧？\n那么 src 源码的作用是什么呢？就是用来更好的归类整理我们的源代码，它有可能是跟我们实际运行的代码结构完全不一样，因为实际运行的是机器能读懂的，而源码是给人看的。\n所以前端也一样，由于当前阶段，前端的业务逻辑也变的非常复杂，再不是传统意义上的一个 html、一个js、一个css就能搞定的。所以我们要分模块，分目录存放源码，最终通过打包再组装成浏览器可以读懂的代码和目录结构。\n比如：我们通过vue的脚手架创建一个vue的webpack项目，看看它的默认的源码目录（src）的树结构：\nsrc ├── App.vue ├── assets │ └── logo.png ├── components │ └── HelloWorld.vue ├── main.js └── router └── index.js  src中除了有3个子目录 assets components router ，还有2个 .vue 结尾的文件。所以，这种目录结构和文件在浏览器中肯定是无法运行的，如果我们要运行，就必须对它进行编译，翻译成浏览器能读懂的html/js/css文件才行。\n当我们打包以后，看到项目的dist目录下就有了编译以后的，浏览器可执行的代码结构：\ndist ├── index.html └── static ├── css │ ├── app.30790115300ab27614ce176899523b62.css │ └── app.30790115300ab27614ce176899523b62.css.map └── js ├── app.b22ce679862c47a75225.js ├── app.b22ce679862c47a75225.js.map ├── manifest.2ae2e69a05c33dfc65f8.js ├── manifest.2ae2e69a05c33dfc65f8.js.map ├── vendor.7fed9fa7b7ba482410b7.js └── vendor.7fed9fa7b7ba482410b7.js.map  所以，当前前端代码逻辑复杂，各种框架横行的年代，源码都是不能直接在浏览器访问的，都需要借助打包工具，如：gulp、webpack这些工具进行打包翻译，才能得到真正的可执行的文件。\nWebpack 打包原理 一句话概括Webpack的本质：\n webpack 是一个打包模块化js的工具，可以通过Loader转换文件，通过Plugin扩展功能。\n Webpack打包的简易示意图：\n2.6 Sass CSS编译原理 什么是Sass？就是一种能提高CSS开发效率的工具。\n其编译原理是：\n实际在项目中怎么用Sass呢？\n前面在说Webpack的时候说过了，现在前端技术离开打包工具是不能直接运行 ，类似于这种Sass文件也一样。所以，我们只需要在Webpack中增加Sass文件的Loader，这样在代码编译环境，就能自动把Sass文件转换为Css文件，最后引入到Html中的是Css文件，这样页面就能正常渲染了。\nSass有什么好处？\ntest.scss文件：\n$color-red: #00ff00; $color-white: #ffffff; #main p { color: $color-red; width: 97%; .redbox { background-color: $color-red; color: $color-white; } }  如果用传统的css写：\n#main p { color: #00ff00; width: 97%; } #main p .redbox { background-color: #00ff00; color: #ffffff; }  三、一些新技术探索 本节知识点：\n TypeScript PWA GraphQL Flutter  3.1 TypeScript 什么是TypeScript？\n TypeScript 是微软开源发布的JavaScript类型的超集，它可以编译成纯JavaScript。\n它是一个Js框架，可以用来开发前端系统。\n 之所以说TypeScript是JavaScript的超集，就意味着TypeScript在JavaScript的语法基础上，又扩展了更多语法，使得开发更加方便。\n接下来我们看看TypeScript的相比JavaScript额外增加的部分：\n 学Java的同学不要惊慌，个人看来TypeScript就是把Java用JavaScript重新实现了一遍！\n 1、强数据类型\n//Boolean类型 let isDone: boolean = false; //数字类型 let decLiteral: number = 6; //字符串 let name: string = \u0026quot;bob\u0026quot;; //数组 let list: Array\u0026lt;number\u0026gt; = [1, 2, 3]; //函数定义 function add(x: number, y: number): number { return x + y; }  2、接口\ninterface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \u0026quot;Size 10 Object\u0026quot;}; printLabel(myObj);   这里的接口与Java中的接口不一样，TypeScript中的接口仅仅是对参数的一种契约约定，即：参数必须是接口定义的结构和参数名等。\n 3、类\n//定义类 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \u0026quot;Hello, \u0026quot; + this.greeting; } } let greeter = new Greeter(\u0026quot;world\u0026quot;); //类的继承 class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log('Woof! Woof!'); } } //共有、私有变量、方法 class Animal { private id: number; //仅类内部访问，实例无法访问 public name: string;//类内部和实例都可以访问 protected pid: number;//仅类内部和子类可以访问 public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); } }  4、泛型\nfunction identity\u0026lt;T\u0026gt;(arg: T): T { return arg; }  5、枚举\nenum Direction { Up = 1, Down, Left, Right }  3.2 PWA 什么是PWA？\n Progressive Web App, 简称 PWA，是渐进式提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\nPWA 本质上是 Web App，就是运行在手机上的App不是纯Native的，而是很多页面都是网页。\n Web App ，我们都知道就是App中有网页嘛！但是 Progressive 渐进式 又该怎么理解？\n个人理解，渐进式 的意思就是：循序渐进的发展或者改造。\nPWA更直白的意思就是：\n 第一步：我们现在要开发一个App，但是开发纯原生App的维护和扩展成本太高，所以我们需要增加一些网页进去，毕竟网页好维护嘛！（这部分其实就是混合类App，也叫：Hybrid App）\n第二步：但是我们App中增加网页不能太暴力，太暴力容易让用户觉得很不自然，所以需要使用循序渐进的方式进行，那么如何循序渐进的进行才能让用户的体验达到极致（也就是几乎看不出来某一个页面是一个网页！）\n第三步：我们就需要增加一些策略，先保证用户体验，比如：为了保证安全网页全部使用HTTPS、使用离线缓存来减少用户打开页面的等待时间等等。\n 所以，PWA就是以循序渐进的方式，提升混合类APP的用户体验，而影响体验最大的问题就是页面加载，所以PWA最核心的技术就是：离线缓存 ，离线缓存大家普遍采用的方案就是：Service Worker\n3.3 GraphQL 在了解什么是GraphQL之前，我们先了解一下什么是SQL？\n什么是SQL？\n Structured Query Language，一种结构化的查询语言，它是关系式数据库管理系统的标准语言。\n 说白了，SQL是一种特定的语法，也可以称之为是数据库管理的API，操作数据库必须通过这个语法进行。\n什么是GraphQL呢？\n 一种用于API的查询语言\nGraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n 用一组图来说明下：\n那你又要说了？没有GraphQL我现在客户端和后台之间不照样可以交互吗？\n没错！你是这么交互的：\n所以，不是说离开GraphQL我们就不能活，而是它给我们提供了一种全新的API查询交互方式，使得客户端和后台的接口通信更加高效罢了。\n那么GraphQL相比传统的接口请求，都有哪些优势呢？\n1、所见即所得\n//查询条件 { user(uid:1) { uid name } } //返回结果 { \u0026quot;data\u0026quot;: { \u0026quot;user\u0026quot;: { \u0026quot;uid\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;xxx\u0026quot; } } }  传统的API是什么样子？\n//查询条件 { uid : 1 } //返回结果 { \u0026quot;data\u0026quot;: { \u0026quot;user\u0026quot;: { \u0026quot;uid\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;xxx\u0026quot; } } }  2、减少网络请求次数\n只需要一次网络请求，就能获得资源和子资源的数据（例如，上文中文章的评论信息）。\n//查询条件 { article(aid:1) { title content author { uid name } }, comment { content, author { uid name } } }  传统的查询，一般先查询Article，再查询Comment。当然你可以一次性去查，让后台一次性返回来，但是一般没有后台会给你设计这样的一个API：getArticleAndComment，如何按照Restful的接口标准，你应该需要查询2次。\n3、参数类型强校验\nGraphQL规定了一套数据类型，这就保证接口查询的时候，字段类型就被明确定义，而传统的接口一般很难保证查询参数的类型。\n比如，以下就是GraphQL的语法定义：\ntype Starship { id: ID! name: String! length(unit: LengthUnit = METER): Float }  3.4 Flutter 什么是Flutter？\n Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。\n 下图就是使用Flutter开发一款App的样子：\n类似于 React Native 框架一样，Flutter也是可以调用一些App系统级的命令，能让你快速开发一款混合类App（Hybrid App）。\n有兴趣的可以去官网学习：Flutter中文网\n四、两个流行的概念解答 本节知识点：\n 什么是大前端 什么是前端工程化  4.1 什么是大前端 本文的标题是 大前端的技术原理和演变史，现在给大家解答一下，什么是：大前端。\n大前端 就是相比 前端 而言变大了，那么到底传统意义的前端指什么？变成大前端又有哪些东西变大了呢？\n传统的意义的前端指是什么呢？\n 传统的前端就是指直接面对客户的应用或者系统，比如：网页、手机App。\n而开发网页、搞iOS和Android开发的程序员都可以称之为前端工程师。\n只是传统意义来说，前端工程师仅仅指网页开发的人，而iOS和Android开发的一般指客户端开发人员，或者归结到软件工程师岗位去了。\n 那么大前端又指什么呢？其实经过各种资料考证，并没有这么一个明确的定义，只是随着技术的进步，大家有了一种默认的约定，大前端之所以称之为大前端，主要体现在以下一些方面：\n1、大前端 - 前后端分离\n随着前后端职责和技术框架的分离发展，产品对前端的要求越来越高，用户对前端的期待越来越高，前端技术发展越来越快，导致前端这个岗位并没有像JSP时代那种画画页面就完事了。这部分体现的是前端的要求更高，责任越大了。\n2、大前端 - Node全栈\n前后端分离后，前端要独立完成一个事情是不行的，因为缺少后台的支持。但是随着Node的出现，前端可以不用依赖后台人员，也不用学习新的后台语言，就可以轻松搞定后台的这部分事情。这样，面对一些小的系统，前端工程师就可以搞定整个系统。这部分体现了前端的全面性和全栈性。\n3、大前端 - 应对各种端\n传统的前端工程师，一般指网页开发工程师，网站一般指运行在PC浏览器，慢慢的也要运行在手机上。但是，随着移动互联网的发展，突然冒出来更多的移动设备，比如：手机分为Android手机和苹果手机、智能手表、VR/AR技术支撑的可穿戴设备、眼睛、头盔、车载系统、智能电视系统等等。而这些设备都需要前端的支撑，这时候对前端的技术要求、能力要求就更高。这部分体现了前端的涉猎范围变大。\n4、大前端 - 微应用\n当微信小程序出来以后，大家第一感觉是前端又可以火一把啦，不需要后台、不需要服务端，只需要在微信平台上开发网页就可以发布上线了。\n而近期又有国内多个手机厂家联合推出 快应用 , 跟小程序差不多，只是通过简单的前端开发发布以后，用户不需要安装应用就可以直接在类似于小米、vivo、oppo等手机上打开这样的应用。\n类似于这些微应用，免后台、免安装的形式出现，也促使了前端这个行业也将涉及到这样的新型领域中，一起推动技术的进步。这部分体现了前端是时代发展的幸运儿。\n综上所述，我们可以得到一个大致的定义：\n 大前端指前端涉猎范围越来越广、涉及的端越来越多、技术要求越来越高、影响范围越来越大的一种体现。\n 4.2 什么是前端工程化 前端工程化的定义：\n 前端工程化是根据业务特点，将前端开发流程规范化，标准化，它包括了开发流程，技术选型，代码规范，构建发布等，用于提升前端工程师的开发效率和代码质量，最终交付一个稳定性高、扩展性好、易于维护的系统的过程。\n 一般情况下，一个符合前端工程化要求的方案应该包含以下要素：\n 开发规范 模块化开发 组件化开发 组件仓库 性能优化 部署 开发流程 开发工具  另外，我们再谈到工程化，不能只想着前端工程化，而应该站在整个系统考虑如何进行工程化，也就是说对于一整个项目，我们谈到工程化应该考虑哪些因素呢？\n一个系统的工程化建设，应该包含以下因素：\n 目标，搞清楚目标群体，并持续为他们做好最优质的服务； 边界，与别的系统划清界限，同时做好接口，保证自身系统职责定位清晰的同时，管理好依赖系统，增加自身健壮性； 壁垒，自身平台建设，其中就包含了前端工程化建设，以及后台工程化建设，还有项目整体建设等诸多因素。  参考资料  前端开发的历史和趋势-阮一峰 JavaScript语言的历史-阮一峰 关于原生JS的AJAX JavaScript异步编程 YOU MIGHT NOT NEED JQUERY Going Async With ES6 Generators 统一资源标志符-维基百科 统一资源定位符-维基百科 剖析Vue实现原理 - 如何实现双向绑定mvvm Vue.js 服务器端渲染指南 Webpack:Output Management webpack原理与实战-gwuhaolin/blog TypeScript Handbook（中文版） 什么是 PWA GraphQL和RESTful的比较 当我们在谈大前端的时候，我们谈的是什么 前端工程——基础篇-张云龙  ","id":2,"section":"posts","summary":"说明 本文转载自掘金，写得非常好，适合让前端新手有一个全局性的理解和制定学习规划。 作者：村口蹲一郎 时间：2018/07/27 原文：文章链接 简介","tags":["发展史","转载文章"],"title":"转：大前端的技术原理和变迁史","uri":"https://jaylanwood.github.io/2020/04/%E8%BD%AC%E5%A4%A7%E5%89%8D%E7%AB%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%92%8C%E5%8F%98%E8%BF%81%E5%8F%B2/","year":"2020"},{"content":"文章简介 这是一份个人总结的前端生存指南。\n包括前端发展史、人物、书籍、编程相关知识。\n针对人群主要是前端新人，部分内容为了保持简单易懂（对我来说），会写得很简单或者说是片面甚至部分有误，若觉得不对的，请自行点开链接查看来源原文。\n前端发展史简述 静态页面阶段，主要使用 HTML\\CSS\\JavaScript，纯内容展示，页面主要靠跳转。例如新浪、网易这样的门户网站。\n动态页面阶段，主要使用 AJAX，交互丰富，页面布局刷新，例如 Gmail、Google Maps。\n框架阶段，主要使用 Angular、React、Vue 之类的 MVVM 框架，可以比较容易地构建单页应用。模块化、组件化、自动化，webpack，TypeScript，花样真多。\n前端各项技术的重要性 HTML、CSS、JavaScript - 必学，重点学好HTML5、CSS3、ES3、ES5、ES6。\njQuery - 多用就会，可以不深入，但是 jQuery 有很多精妙的设计可以参考。\nAngular、React、Vue - 精通一个\nWebpack - 学会常用配置\nHTTP - 必学\n浏览器渲染原理 - 必学\ngit - 必修\nNode - 选修\nTypeScript - 选修\n前端以外 数据结构与算法 - 懂算法的人善于计算时空复杂度，相当于在你做事情前，懂得怎么去衡量效率和开销。\n计算机操作系统\n计算机网络\n数据库系统\n计算机组成原理\n编译原理 - 将源语言转化为目标语言,也就是将一门语言转化为另一门语言。\n设计模式 - 编程套路。\n现在的前端能做什么  游戏开发(Egret Layabox coco2d-js) web开发(pc 移动端设备) webApp开发(Dcloud RN weex ionic) 图形开发WebGl(three.js) 小程序/快应用 后端(nodejs) 桌面应用(electron) 嵌入式开发(Ruff)  前端可以关注的人 阮一峰\n方应杭\n司徒正美\n张鑫旭\n尤雨溪\n廖雪峰\n前端可以关注的网站 MDN\nCSS-Trick\n前端可以看的书 《代码大全》 名称：Code Complete\n作者：Steve McConnell\n出版时间：\n第1版：1993\n第2版：2004\n评价：据说可以看十年，遇到什么问题想不通，可以看。\n《ECMAScript 6入门》 名称：ECMAScript 6入门\n作者：阮一峰\n出版时间：\n第3版：2017\n评价：阮一峰的书，而且网络开源更新，看。\n《你不知道的JavaScript》 名称：You Don\u0026rsquo;t Know JS Yet\n作者：Kyle Simpson\n出版时间：\n上：2015\n中：2016\n下：2018\n评价：还算比较新，可以看。\n《JavaScript忍者秘籍》 名称：Secrets of the JavaScript Ninja\n作者：John Resig / Bear Bibeault\n出版时间：\n第1版：2013\n第2版：2018\n评价：jQuery 作者的书，看就完事。\n《JavaScript高级程序设计》 名称：Professional JavaScript for Web Developers\n作者：Nicholas C.Zakas\n出版时间：\n第3版：2012\n评价：经典书，但年代久远，ES6都出来了，大人时代变了！有空再看，或者抽重点部分看。\n《JavaScript权威指南》 名称：JavaScript: The Definitive Guide\n作者：David Flanagan\n出版时间：\n第1版：2006\n第6版：2012\n评价：经典书，但年代久远，ES6都出来了，大人时代变了！有空再看，或者抽重点部分看。\n《JavaScript语言精粹》 名称：JavaScript: The Good Parts\n作者：Douglas Crockford\n出版时间：\n第1版：2008\n评价：经典书，但年代久远，ES6都出来了，大人时代变了！有空再看，或者抽重点部分看。\n《图解HTTP》 名称：图解HTTP\n作者：上野宣\n出版时间：\n第1版：2014\n评价：很多图解，看。\n《JavaScript DOM编程艺术》 名称：DOM Scripting: Web Design with JavaScript and the Document Object Model\n作者：Jeremy Keith\n出版时间：\n第2版：2011年\n评价：JavaScript入门很适合看。\n《JavaScript设计模式》 名称：Learning JavaScript Design Patterns\n作者：Addy Osmani\n出版时间：\n第1版：2013年\n评价：JavaScript设计模式的书不多，但是书太旧，有空再看。\n《编写可维护的JavaScript》 名称：Maintainable JavaScript\n作者：Nicholas C. Zakas\n出版时间：\n第1版：2012\n评价：经典书，但年代久远，ES6都出来了，大人时代变了！有空再看，或者抽重点部分看。\n《HTTP权威指南》 名称：HTTP: The Definitive Guide\n作者：David Gourley\n出版时间：\n第1版：2012\n评价：经典书，但年代久远，ES6都出来了，大人时代变了！有空再看，或者抽重点部分看。\n《写给大家看的设计书》 名称：The Non-Designer\u0026rsquo;s Design Book\n作者：Robin Williams\n出版时间：\n第4版：2016\n评价：设计方面的书，万一想不开，自己去设计网页呢。\n1989 - World Wide Web（万维网） 名称：World Wide Web（万维网）\n创建者：Tim Berners-Lee\n目的：\nTim Berners-Lee 在欧洲核子研究组织 (CERN) 工作时，那里有来自世界各地的人，他们带着差异性很大的电脑，电脑里面有不同格式的文档、文件系统。而他需要文档里的数据。他想把文档都放在一起，点一下，就跳转到某一个文档。于是他发明了万维网（World Wide Web）。\nTED-The next web：\n 主要相关技术：\nURI、HTML、HTTP\n相关网站：W3C官方\n1989 - URI（Uniform Resource Identifier） 名称：URI 统一资源标识符\n创建者：Tim Berners-Lee\n目的：保证资源统一、明确。\n主要相关技术：\nURI 分为 URN 和 URL\nURN（Uniform Resource Name）是名称统一，例如通过 ISBN 0-486-27557-4 可以在图书管里找到一本书。\nURL（Uniform Resource Locator）是位置统一，例如通过 http://example.org/wiki/Main_Page 找到 wiki/Main_Page 这个位置，但是这个位置的内容是可变的。\n示例：\n userinfo host port ┌──┴───┐ ┌──────┴──────┐ ┌┴┐ https://john.doe@www.example.com:123/forum/questions/?tag=networking\u0026amp;order=newest#top └─┬─┘ └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘ scheme authority path query fragment  1989 - HTML（Hypertext Markup Language） 名称：HTML 超文本标记语言\n创建者：Tim Berners-Lee\n目的：展示文档，让文档结构化、语义化，点击可跳转其他文档。\n发展史：\n 1989 - HTML 1995 - HTML 2 1997 - HTML 3 1997 - HTML 4 2014 - HTML 5  示例：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; www.Example.org \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;万维网 \u0026lt;/p\u0026gt; \u0026lt;a href=\u0026quot;https://www.w3.org/\u0026quot;\u0026gt;W3C\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  相关网站：HTML-MDN\n1989 - HTTP（Hypertext Transfer Protocol） 名称：HTTP 超文本传输协议\n创建者：Tim Berners-Lee\n目的：浏览器和服务器之间传输内容做好沟通协调，不要乱来。\n示例：\nHTTP请求示例\ncurl -s -v -H \u0026quot;Jack: xxx\u0026quot; -- \u0026quot;https://www.baidu.com\u0026quot;  \u0026gt; GET / HTTP/1.1 \u0026gt; Host: www.baidu.com \u0026gt; User-Agent: curl/7.64.1 \u0026gt; Accept: */* \u0026gt; Jack: xxx  HTTP响应示例\n\u0026lt; HTTP/1.1 200 OK \u0026lt; Content-Type: text/html \u0026lt; Date: Wed, 08 Apr 2020 03:18:29 GMT \u0026lt; \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt;  相关网站：HTTP-MDN\n1990 - Web browser（网络浏览器） 名称：Web browser 网络浏览器\n创建者：Tim Berners-Lee\n目的：最初访问万维网是用命令行的（例如你可以curl），而图形化的网络浏览器可以更直观地访问。\n发展史：\n 1990 - WorldWideWeb，由 Tim Berners-Lee 发布，后更名为Nexus，1994年停产。 1993 - Mosaic，由美国国家超级计算应用中心（NCSA）发布，世界上第一个流行的浏览器。 1994 - Navigator，由 Mosaic 团队负责人成立的公司 Netscape 发布，最受欢迎的浏览器。 1995 - Internet Explorer，捆绑在 Windows 系统的浏览器，后打败 NetscapeNavigator 成为霸主。 1998 - Firefox，Netscape 打不过微软 IE，推出了 Mozilla 基金会，开源了 Navigator，并改名为 Firefox 于 2004 年发布。 2003 - Safari 由苹果发布。 2008 - Chrome 由 Google 发布。于 2012 年成为最受欢迎的浏览器，此后占据主导地位。  示例：\n在 IE 浏览器上地址栏输入 https://www.google.com/chrome，下载 Chrome 浏览器并安装。\n1996 - CSS（Cascading Style Sheets） 名称：CSS 层叠样式表\n创建者：Håkon Wium Lie\n目的：HTML 发展到一定程度，甚至用 html 标签（例如\u0026lt;center\u0026gt;)来实现外观样式，CSS 旨在使 html 内容和外观样式分离。\n发展史：\n1996 - CSS 1\n1998 - CSS 2 和 CSS 2.1，CSS 2.1 修改了 CSS 2 中的错误，增加了已有的浏览器的扩展内容。\n2011 - CSS 3，CSS 被拆分为多个模块单独升级，统称为 CSS 3，CSS Specification\n示例：\nbody{ width: 100px; height: 100px; background-color: red; }  相关技术：\nLess、Sass、PostCSS\n相关网站：\nCSS-W3C\nCSS-MDN\nCSS-Tricks\nCSS-张鑫旭\n1997 - JavaScript 和 ECMAScript 名称：\nJavaScript\nECMAScript\n创始人：Brendan Eich\n目的：刚开始网页只能是静态的，需要一门语言来实现动态交互。例如在登陆时提示用户输入用户名。\n设计思路：\nECMAScript Harmony: Rise of the Compilers\n 发展史：\n 1995 - Netscape 决定向 Navigator 添加脚本语言，于是雇佣 Brendan Eich 设计了一门新的语言，刚开始名字叫做Mocha，后改为LiveScript，最后又改名为 JavaScript。 1996 - 微软模仿 JavaScript 开发了 JScript，并内置在 IE3.0 中。 1996 - Netscape 衰落后，为了抵抗让微软，把 JavaScript 提交给 ECMA 组织。 1997 - ECMAScript 1.0，ECMA 发布 ECMA-262 文件，规定了浏览器脚本语言的标准并称为ECMAScript 1.0，其实就是 JavaScript。 1998 - ECMAScript 2.0 发布 1999 - ECMAScript 3.0 发布 2007 - ECMAScript 4.0 分歧太大，胎死腹中，最后把涉及现有功能改善的一小部分，发布为 ECMAScript 3.1。 2009 - ECMAScript 5.0 发布，新增部分特性，其实就是 ECMAScript 3.1。 2011 - ECMAScript 5.1 发布 2015 - ECMAScript 6.0 发布，又称 ECMAScript 2015，新增大量特性，终于达到成熟阶段。此后，每年都发布ECMAScript 并以年份为名，但更改范围比较小。 2016 - ECMAScript 7.0 发布 2017 - ECMAScript 8.0 发布，正式引入了 async 函数，使得异步操作的写法出现了根本的变化。 2018 - ECMAScript 9.0 发布 2019 - ECMAScript 10.0 发布  示例：\nvar person = { name: 'Jack', age: 18, wife: undefined, job: null, skills: ['read', 'swim', 'run'], sayName: function () { console.log(this.name) } }  相关网站：\nBrendan Eich主页\nJavaScript-MDN\nJavaScript 教程-阮一峰\nECMAScript 6 入门-阮一峰\n1998 - DOM（Document Object Model） 目的：把 XML 和 HTML 文档作为树结构，每个节点是一个对象，让 JavaScript 可以操作这些对象。\n发展史：\n 1998 - DOM Level 1 2000 - DOM Level 2 2004 - DOM Level 3 2015 - DOM Level 4  示例：\nvar body = document.querySelector('body')  相关网站：\nDOM-MDN\n2000 - JSON 名称：JSON\n创建者：Douglas Crockford\n目的：数据交换格式，和 XML 五五开，成为 AJAX 主流的数据交换格式。\n相关网站：\nJSON官方\nJSON-MDN\n2004 - CORS（Cross-origin resource sharing） 名称：CORS\n创建者：Matt Oshry，Brad Porter和Michael Bodell\n目的：允许跨域资源共享，AJAX 需要 CORS，其他 a\\img\\script 之类都不需要。\n相关网站：CORS-MDN\n示例：\n后端设置相应头允许 CORS\nresponse.setHeader(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;*\u0026quot;)  2005 - JSONP（JSON with Padding） 名称：JSONP\n创建者：Bob Ippolito\n目的：通过\u0026lt;script\u0026gt;标签来请求数据，可绕过同源策略。\n示例：\n前端\nvar callbackName = 'jaylan' + parseInt(Math.random() * 10000000, 10) window[callbackName] = function (result) { console.log(result) } var script = document.createElement('script') script.src = '/weather?callback=' + callbackName document.body.appendChild(script) script.onload = function (eee) { eee.currentTarget.remove() delete window[callbackName] } script.onerror = function (eee) { eee.currentTarget.remove() delete window[callbackName] }  后端\nvar server = http.createServer(function (request, response) { var parsedUrl = url.parse(request.url, true) var query = parsedUrl.query if (path === '/weather') { let callback = query.callback response.statusCode = 200 response.setHeader('Content-Type', 'application/json') response.write(` ${callback}.call(undefined,{ \u0026quot;beijing\u0026quot;:\u0026quot;rain\u0026quot;, \u0026quot;guangzhou\u0026quot;:\u0026quot;cloud\u0026quot; }) `) response.end() } })  jQuery 发 JSONP\n// jQuery把JSONP归类在ajax，不用在意。 $.ajax({ url: \u0026quot;/weather\u0026quot;, jsonp: \u0026quot;callback\u0026quot;, dataType: \u0026quot;jsonp\u0026quot;, success: function (response) { console.log(response) } })  2005 - WebKit 名称：WebKit\n创建者：苹果\n目的：苹果公司在 KHTML 引擎基础上，建立了 WebKit 浏览器引擎。\n相关网站：Webkit官方\n2005 - CouchDB 名称：CouchDB\n创建者：Apache软件基金会\n目的：基于 JSON 格式的数据库，可以用 JavaScript 函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着 NoSQL 类型的数据库诞生。\n相关网站：CouchDB官方\n2005 - XMLHttpRequest 和 AJAX（Asynchronous JavaScript and XML） 名称：AJAX - 异步的 JavaScript 和 XML\n最初实现：微软 IE5 的 XMLHTTP ActiveX 的私有借口\n命名者：Jesse James Garrett\n目的：AJAX 是一组技术组合。它可以向服务器发送任意类型的请求，异步地接收响应，使得不会阻塞页面，并且可以局部刷新页面。\n历史：\n 1996 - IE 引入 iframe，可以异步加载和获取内容。 1998 - Microsoft Outlook Web Access 团队开发了 XMLHttpRequest 脚本对象背后的概念。 1999 - 微软在 IE5 中实现了 XMLHTTP ActiveX 的私有借口，可以用 JS 直接发起 HTTP 请求。后来各家浏览器纷纷跟进，取名 XMLHttpRequest，并纳入 W3C 规范。 2004 - Gmail 和 Google Maps 把 AJAX 玩得出神入化，局部刷新、异步，像一个桌面应用那样，展现了 Web application 的强大。 2005 - Jesse James Garrett 发文章把这种技术组合成为 Ajax。 2006 - W3C 把 XMLHttpRequest 对象纳入标准规范。  示例：\n原生 JS 写法\nlet request = new XMLHttpRequest() request.open('GET', '/getWeather') request.onreadystatechange = () =\u0026gt; { if (request.readyState === XMLHttpRequest.DONE) { if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status) { console.log(request.responseText) } } } request.send()  jQuery 的 AJAX 写法\n$.ajax({ url: \u0026quot;/getWeather\u0026quot;, data: { local: 'beijing' }, success: function (result) { $(\u0026quot;#weather\u0026quot;).html(result); } })  后端服务器写法参考\nif (path === '/getWeather') { response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write('Rain') response.end() }  相关网站：\nXMLHttpRequest-MDN\nAJAX-MDN\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)\n相关库：\naxios\n2006 - jQuery 名称：jQuery\n创建者：John Resig\n目的：jQuery 是 JavaScript 超级经典的库，旨在简化 HTML DOM 树的遍历和操作以及事件处理，CSS 动画和 Ajax。\n示例：\n\u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;weather\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $('.box').css({ 'width': '100px', 'height': '100px', 'background-color': 'green' }).on('click', function () { $.ajax({ url: \u0026quot;/getWeather\u0026quot;, data: {local: 'beijing'}, success: function (result) { $(\u0026quot;#weather\u0026quot;).html(result); } }); }) \u0026lt;/script\u0026gt;  相关网站：\njQuery官方\njQuery非官方中文网\n2006 - Sass 和 Scss（Syntactically Awesome Style Sheets） 名称：Sass 语法很棒的 CSS\n创建者：Natalie Weizenbaum\n目的：\nRuby的人觉得CSS很烂，于是做一个语法更好版本的Sass。Sass语法让习惯用CSS的人用不习惯，于是做得更像CSS的Scss。\nSass 是一种预处理器脚本语言，需要编译为CSS才能被浏览器识别。\n示例：\nCSS\nbody { font: 100% Helvetica, sans-serif; color: #333; }  Sass\n$font-stack: Helvetica, sans-serif $primary-color: #333 body font: 100% $font-stack color: $primary-color  Scss\n$font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; }  相关网站：Sass官方\n2008 - WebSocket 名称：WebSocket\n创建者：Michael Carter\n目的：HTTP是单向通信的，WebSocket提供全双工通信。\n相关网站：WebSockets-MDN\n2008 - V8（JavaScript engine） 名称：V8\n创建者：Google\n目的：为 Chrome 浏览器而开发的，让 JavaScript 的运行变得非常快。\n相关网站：V8官方\n2009 - Node.js 名称：Node.js\n创建者：Ryan Dahl\n目的：基于 Chrome V8 引擎的 JavaScript 运行时，使得 JavaScript 可以用于服务器端编程。\n相关网站：Node官方\n2009 - CommonJS 名称：CommonJS\n创建者：\n目的：JavaScript 诞生之初是没有模块的，CommonJS 旨在在 Web 浏览器之外为 JavaScript 建立模块生态系统。\n相关网站：CommonJS官方\n相关技术：\nRequireJS - 创建 AMD(Async Module Definition) 模块规范\nSea.js - 创建 CMD(Common Module Definition) 模块规范\n2009 - CoffeeScript   名称：CoffeeScript\n创建者：Jeremy Ashkenas\n目的：CoffeeScript 可转换为 JavaScript 运行，语法更简洁，对 JavaScript 后来的版本有着很大影响。\n相关网站：CoffeeScript官方\n2009 - PhoneGap \n名称：PhoneGap\n创建者：Nitobi\n目的：移动应用程序开发框架，主要针对 iOS 和 Android，使得 JavaScript 可以用于跨平台的应用程序开发。\n相关网站：PhoneGap官方\n2009 - Less（Leaner Style Sheets） 名称：Less 初学者的 CSS\n创建者：Alexis Sellier\n目的：做初学者快速易学版本的 CSS。Less 是一种预处理器脚本语言，需要编译为CSS才能被浏览器识别。\n示例：\nCSS\n#header { width: 10px; height: 20px; }  Less\n@width: 10px; @height: @width + 10px; #header { width: @width; height: @height; }  相关网站：Less官方\n2010 - NPM（Node Package Manager） \n名称：NPM\n创建者：Isaac Z. Schlueter\n目的：Node.js 的默认包管理器，标志着 JavaScript 进入模块化开发的时代。\n相关网站：npm官方\n示例：\nnpm install jquery  2010 - BackboneJS 名称：BackboneJS\n创建者：Jeremy Ashkenas\n目的：MVP 框架，被设计用于开发单页的 Web 应用程序（SPA）。\n相关网站：BackboneJS官方\n2011 - Browserify 名称：Browserify\n创建者：Browserling team\n目的：浏览器本身不支持模块，Browserify 让您在浏览器中使用模块，就像在 Node 中使用模块一样。\n相关网站：Browserify官方\n2011 - D3.js 名称：D3.js\n创建者：Mike Bostock, Jason Davies, Jeffrey Heer, Vadim Ogievetsky\n目的：数据可视化。\n相关网站：\nD3.js官方\nECharts官方 - 类似项目，偏重于展示。\n2011 - Dart 名称：Dart\n创建者：Google\n目的：结束JavaScript语言在浏览器中的垄断，Chromium浏览器有内置的Dart虚拟机，可以运行Dart程序，但Dart程序也可以被编译成JavaScript程序运行。\n相关网站：Dart官方\n2012 - AngularJS 名称：AngularJS\n创建者：Google\n目的：框架，解决开发单页应用程序时遇到的许多挑战。\n相关网站：AngularJS官方\n2012 - Ember.js 名称：Ember.js\n创建者：Yehuda Katz\n目的：MVVM框架，解决开发单页应用程序时遇到的许多挑战。\n相关网站：Ember官方\n2012 - TypeScript 名称：TypeScript\n创建者：Microsoft\n目的：严格的语法 JavaScript 超集，并增加了可选的静态类型，为开发大型应用程序而设计的，并可以编译为JavaScript。可以避免很多 JavaScript 由于数据类型引起的 bug。\n相关网站：TypeScript官方\n2012 - Webpack 名称：Webpack\n创建者：Tobias Koppers, Sean Larkin, Johannes Ewald, Juho Vepsäläinen, Kees Kluskens\n目的：JavaScript 的模块捆绑器（bundle），转换.js .jpg .sass之类的各种前端资产。把具有依赖性的模块，生成静态资产。\n相关网站：Webpack官方\n相关技术：\nparce - 极速零配置Web应用打包工具。\nGrunt - 命令行工具（CLI），用于自动执行需要常规执行的任务。\nGulp - 命令行工具（CLI），用于自动执行需要常规执行的任务。\n2013 - React 名称：React\n创建者：Jordan Walke 和 Facebook\n目的：UI 框架库，引入了新的 JSX 语法，使得 UI 层可以用组件开发，同时引入了网页应用是状态机的概念。\n相关网站：React官方\n2013 - PostCSS 和 Autoprefixer 名称：PostCSS\n创建者：Andrey Sitnik, Ben Briggs, Bogdan Chadkin\n目的：\nPostCSS 是用于开发 CSS 工具的框架，例如可以开发 Sass 和 Less。\nAutoprefixer 是 PostCSS 的插件，可以解析 CSS 并添加浏览器前缀。\nWebpack、Grunt 和 Gulp 调用 PostCSS 的Autoprefixer插件，可以把Less、Sass等处理成CSS。\n示例\nAutoprefixer\n.example { transition: all .5s; }  CSS\n.example { -webkit-transition: all .5s; -o-transition: all .5s; transition: all .5s; }  相关网站：\nPostCSS官方\nAutoprefixer\n2014 - Vue.js 名称：Vue.js\n创建者：尤雨溪 - Evan You\n目的：MVVM框架，构建用户界面和单页应用。\n相关网站：Vue.js官方\n2015 - React Native 名称：React Native\n创建者：Facbook\n目的：将 React 框架移植到了手机端，可以将 JavaScript 代码转换成 ios 和 android 的原生代码，创建原生APP。\n相关网站：React Native官方\n2015 - Babel (transcompiler) 名称：Babel\n创建者：Sebastian McKenzie\n目的：JavaScript 编译器，可以把最新的 JavaScript 语法转换成旧语法，以兼容浏览器。最初出名是因为把 ES6 转成 ES5，使得开发者开心用 ES6 而不用担心浏览器兼容性问题。\n相关网站：Babel官方\n2017 - Flutter 名称：Flutter\n创建者：Google\n目的：用 Dart 语言开发多端应用程序。\n相关网站：Flutter官方\n","id":3,"section":"posts","summary":"文章简介 这是一份个人总结的前端生存指南。 包括前端发展史、人物、书籍、编程相关知识。 针对人群主要是前端新人，部分内容为了保持简单易懂（对我来说","tags":["发展史"],"title":"前端生存指南","uri":"https://jaylanwood.github.io/2020/04/%E5%89%8D%E7%AB%AF%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/","year":"2020"},{"content":"模块化、MVC化、对象化、类化 简介 记录由一坨很乱的代码到很简洁有条理的代码的过程。\n很乱的代码\u0026ndash;\u0026gt;模块化\u0026ndash;\u0026gt;MVC化\u0026ndash;\u0026gt;对象化\u0026ndash;\u0026gt;类化\n代码 代码地址\n代码范围：从 模块化 到 message的类化\n1.很乱的一坨代码 简述 一坨代码写在一起，各种全局变量，容易互相覆盖，而且代码很乱，没条理。\n关键 变量 + 函数 + 函数调用\n模块化 简述 把一堆各种功能的代码分成各种js文件，例如：run.js、print.js，每个js文件用立即执行函数实现局部变量。\n关键 立即执行函数\n代码 index.html\n\u0026lt;script src=\u0026quot;run.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;print.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  print.js\n! function () { // 原本功能的代码 var abc = 100 function hehe() { console.log(abc += 1) } hehe() }.call()  2.模块之间沟通共享 简述 多个模块之间可能需要互相沟通数据，此时需要通过闭包实现。\n关键 闭包\n代码 闭包\n// 闭包 function bibao() { var abc = 100 function hehe() { console.log(abc += 1) } return hehe } // 其他人使用这个闭包。能用hehe函数给abc+1，但是完全不知道abc的值。 var usebibao = bibao() usebibao()  立即执行函数+闭包\n! function () { var abc = 100 window.hehe = function () { console.log(abc += 1) } }.call(); // 其他人能使用window.hehe函数给abc+1，但是完全不知道abc的值。 window.hehe()  3.vc化 简述 引入MVC思想，使得代码更有组织，但是前端在没有操作数据时，Model是没有的，所以VC化很常见。\n关键 把代码归类，html相关的基本属于view，剩下的就是controller。\n代码 ! function () { var view = document.querySelector('.className') var controller = function (view) { var viewSon = view.querySelector('.className') console.log(view) console.log(viewSon) } controller(view) }.call()  4.对象化 简述 把代码对象化。\n关键 把相关的函数、变量挂到controller的属性。\n注意：使用this要注意this被监听函数修改为触发事件的对象，可以用箭头函数修正，箭头函数的this会就进取。\n代码 ! function () { var view = document.querySelector('.className') var controller = { view: null, viewSon: null, // viewSon是saySon函数需要的，也要初始化 init: function (view) { this.view = view this.viewSon = this.view.querySelector('.className') this.hehe() this.saySon() }, hehe: function () { var view = this.view console.log(view) }, saySon: function () { console.log(this.viewSon) }, } controller.init.call(controller, view) }.call() // 运行过程： // 1.controller.init.call(controller, view) 把controller和外面的变量view传进init函数里去 // 2.this.view = view 把变量view赋值给controller.view // 3.this.hehe() 把controller传进hehe函数里去 // 4.var view = this.view 声明一个view变量，controller.view赋值给这个变量 // 5.console.log(view) 把view打印出来。 // 整个过程中 this 一直都是controller， // 外面的变量view赋值给了controller.view // controller.view又赋值给了hehe函数里新声明的view // 最后console.log(view)把hehe函数里的view打印出来 // 写法流程： // 1.把controller写成一个对象 // 2.controller需要一个view、init、执行函数hehe // 3.init把需要执行的函数hehe和view关联起来 // 4.init调用，把外面的view交给controller，并调用hehe函数，hehe函数就运行成功  5.MVC化 简述 对于有数据操作的代码，还要在VC化的基础上，把M分离出来。\n关键 一般VC化后，从controller里把数据相关的函数拿出来放进Model里就行了。\n注意：使用this要注意this被监听函数修改为触发事件的对象，可以用箭头函数修正，箭头函数的this会就进取。\n代码 模块化\n// 留言板-模块化.js ! function () { let messageList = document.querySelector('.messageList') let postMessageForm = document.querySelector('.postMessageForm') AV.init({ appId: \u0026quot;XXXXXX\u0026quot;, appKey: \u0026quot;XXXXXX\u0026quot;, }); loadMessage() bindEvents() function loadMessage() { var query = new AV.Query('message'); query.find() .then(function (message) { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` messageList.append(li) }) }) } function bindEvents() { postMessageForm.addEventListener('submit', function (eee) { eee.preventDefault() // 阻止表单提交默认刷新页面事件 saveMessage() }) } function saveMessage() { let name = postMessageForm.querySelector('input[name=name]').value let content = postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); message.save() .then(function (object) { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` messageList.append(li) postMessageForm.querySelector('input[name=content]').value = '' }) } }.call()  VC化\n// 留言板-VC化.js ! function () { var view = document.querySelector('.message') var controller = { view: null, messageList: null, postMessageForm: null, init: function (view) { this.view = view this.messageList = this.view.querySelector('.messageList') this.postMessageForm = this.view.querySelector('.postMessageForm') this.initAV() this.loadMessage() this.bindEvents() }, initAV: function () { AV.init({ appId: \u0026quot;XXXXXX\u0026quot;, appKey: \u0026quot;XXXXXX\u0026quot;, }); }, loadMessage: function () { var query = new AV.Query('message'); query.find() .then((message) =\u0026gt; { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` this.messageList.append(li) }) }) }, bindEvents: function () { this.postMessageForm.addEventListener('submit', (eee) =\u0026gt; { eee.preventDefault() // 阻止表单提交默认刷新页面事件 this.saveMessage() }) }, saveMessage: function () { let name = this.postMessageForm.querySelector('input[name=name]').value let content = this.postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); message.save() .then((object) =\u0026gt; { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` this.messageList.append(li) this.postMessageForm.querySelector('input[name=content]').value = '' }) }, } controller.init(view) }.call()  MVC化\n// 留言板-MVC化.js ! function () { var view = document.querySelector('.message') var model = { init: function () { AV.init({ appId: \u0026quot;XXXXXX\u0026quot;, appKey: \u0026quot;XXXXXX\u0026quot;, }); }, fetch: function () { var query = new AV.Query('message'); return query.find() }, save: function (name, content) { var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); return message.save() }, } var controller = { view: null, model: null, messageList: null, postMessageForm: null, init: function (view, model) { this.view = view this.model = model this.messageList = this.view.querySelector('.messageList') this.postMessageForm = this.view.querySelector('.postMessageForm') this.model.init() this.loadMessage() this.bindEvents() }, loadMessage: function () { this.model.fetch().then((message) =\u0026gt; { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` this.messageList.append(li) }) }) }, bindEvents: function () { this.postMessageForm.addEventListener('submit', (eee)=\u0026gt; { eee.preventDefault() // 阻止表单提交默认刷新页面事件 this.saveMessage() }) }, saveMessage: function () { var name = this.postMessageForm.querySelector('input[name=name]').value var content = this.postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 this.model.save(name, content).then((object) =\u0026gt; { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` this.messageList.append(li) this.postMessageForm.querySelector('input[name=content]').value = '' }) }, } controller.init(view, model) }.call()  6.类化 简述 把MVC化的代码公共部分提取出来，分成3个js文件，其他文件再去使用这3个MVC文件。\n关键 1.把公有的代码拿出来做成一个object对象\n2.私有的代码作为参数以options对象传进MVC函数\n3.object作为this去调用options的私有函数init\n4.遍历options的属性拿到其余的属性\n5.返回object，它有公有属性，也有私有属性。\n代码 以message.js为例。\nView.js\n// 1.改造前 var view = document.querySelector('.message') // 私有部分是'.message' // 2.类化 window.View = function (selector) { return document.querySelector(selector) } // 3.使用方 var view = View('.message')  Model.js\n// 1.改造前 var model = { init: function () { AV.init({ appId: \u0026quot;mJuVhxO68GtStDWtrhFJUX8t-gzGzoHsz\u0026quot;, appKey: \u0026quot;heQIds6bW7KitjLNGrrYGYv8\u0026quot;, }); }, fetch: function () { var query = new AV.Query('message'); return query.find() }, save: function (name, content) { var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); return message.save() }, } // 私有部分是'message' // 2.类化 window.Model = function (options) { let resourceName = options.resourceName return { init: function () { AV.init({ appId: \u0026quot;mJuVhxO68GtStDWtrhFJUX8t-gzGzoHsz\u0026quot;, appKey: \u0026quot;heQIds6bW7KitjLNGrrYGYv8\u0026quot;, }); }, fetch: function () { var query = new AV.Query(resourceName); return query.find() }, save: function (object) {// 把原本的name和content合成一个object var Message = AV.Object.extend(resourceName); var message = new Message(); message.set('name', object.name); message.set('content', object.content); return message.save() }, } } // 3.使用方 var model = Model({resourceName: 'message'})  Controller.js\n// 1.改造前 var controller = { view: null, model: null, messageList: null, postMessageForm: null, init: function (view, model) { this.view = view this.model = model this.messageList = this.view.querySelector('.messageList') this.postMessageForm = this.view.querySelector('.postMessageForm') this.model.init() this.loadMessage() this.bindEvents() }, loadMessage: function () { this.model.fetch().then((message) =\u0026gt; { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` this.messageList.append(li) }) }) }, bindEvents: function () { this.postMessageForm.addEventListener('submit', (eee) =\u0026gt; { eee.preventDefault() // 阻止表单提交默认刷新页面事件 this.saveMessage() }) }, saveMessage: function () { var name = this.postMessageForm.querySelector('input[name=name]').value var content = this.postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 this.model.save(name, content).then((object) =\u0026gt; { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` this.messageList.append(li) this.postMessageForm.querySelector('input[name=content]').value = '' }) }, } // 私有部分是messageList、postMessageForm、loadMessage、bindEvents、saveMessage // 公有部分是view、model、init的一部分 // 2.类化 window.Controller = function (options) { // 拿到私有的init var init = options.init let object = { view: null, model: null, init: function (view, model) { this.view = view this.model = model this.model.init() // 调用私有的init init.call(this, view, model) // 相当于 options.init.call(object, view, model) this.bindEvents() }, } // 拿到init以外的私有属性 for (let key in options) { if (key !== 'init') { object[key] = options[key] } } return object } // 3.使用方 var controller = Controller({ init: function (view, model) { this.messageList = this.view.querySelector('.messageList') this.postMessageForm = this.view.querySelector('.postMessageForm') this.loadMessage() }, loadMessage: function () { this.model.fetch().then((message) =\u0026gt; { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` this.messageList.append(li) }) }) }, bindEvents: function () { this.postMessageForm.addEventListener('submit', (eee) =\u0026gt; { eee.preventDefault() // 阻止表单提交默认刷新页面事件 this.saveMessage() }) }, saveMessage: function () { var name = this.postMessageForm.querySelector('input[name=name]').value var content = this.postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 this.model.save({ 'name': name, 'content': content }).then((object) =\u0026gt; { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` this.messageList.append(li) this.postMessageForm.querySelector('input[name=content]').value = '' }) }, }) controller.init(view, model)  ","id":4,"section":"posts","summary":"模块化、MVC化、对象化、类化 简介 记录由一坨很乱的代码到很简洁有条理的代码的过程。 很乱的代码\u0026ndash;\u0026gt;模块化\u0026ndash;\u0026gt","tags":["MVC","模块","对象","类"],"title":"模块化、MVC化、对象化、类化","uri":"https://jaylanwood.github.io/2020/02/%E6%A8%A1%E5%9D%97%E5%8C%96mvc%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%8C%96%E7%B1%BB%E5%8C%96/","year":"2020"},{"content":"从注册登陆实例学习Cookie\\Session\\LocalStorage\\SessionStorage\\Cache-Control\\Expires\\ETag\\Last-Modified 简介 从做一个注册、登陆、主页、服务端的过程，学习相关的前端知识。\n注册 sign_up.html\n登陆 sign_in.html\n主页 index.html\n服务端 server.js\n效果 Sign_up页面 注册表单\n 邮箱 密码 确认密码 注册按钮  Sign_in页面 登陆表单\n 邮箱 密码  Index主页 显示密码 你的密码是：xxx\n代码 代码地址\n注册流程 前端发请求  遍历 form 表单里 email、password、password_confirmation 的 3 个值 把 3 个值赋值给一个 hash { email:'123@jj.com', password:'123', password_confirmation:'123' } 通过 ajax 请求把 hash 作为请求体字符串发给服务器 $.post('/sign_up', hash)  后端发响应  拿到请求，进行 URI 解码、分割 hash 字符串、合成新 hash。 校验 email 格式，校验密码一致性，读取数据库检查 email 是否已经存在。 都通过，就把 email 和 password 新增写入数据库。给前端响应注册成功的 JSON 字符串。 若不通过，响应相应错误的 JSON 字符串。  前端收响应  拿到成功的200响应，在页面显示类似“恭喜你注册成功”之类的提示。 若拿到失败的400响应，则根据响应的 JSON 在页面展示“邮箱格式错误、邮箱已被使用、密码格式错误”之类的提示。  其他细节  前端也可以在发请求前，对 hash 请求体做验证。例如 用正则验证email、password的规则 password === password_confirmation 验证密码一致性 遍历 email 字符串去空格 但是，无法验证 email 是否已被使用，因为数据在服务器。 前端的验证不是必须的，但是后端是肯定有验证的。  首次登陆流程 前端发请求 和注册一样，把 email、password 合成一个 hash\n通过 ajax 把 hash 字符串发给服务器。$.post('/sign_in', hash)\n后端发响应  拿到请求，进行 URI 解码、分割 hash 字符串、合成新 hash 。 遍历数据库的 email 和 password 做对比。 若不通过，响应相应错误的 JSON 字符串。 若通过，生成一个随机数的 SessionID，用一个名为 Session 的 hash 存下 {SessionID:email}这样的对照表。 后端再通过 Cookie 给前端发送 SessionID。  前端收响应 前端若是收到服务器发来的401响应和相关的 JSON，则提示用户相应的错误，如密码错误之类。\n前端若是收到带 SessionID 的 Cookie 相应头，以及响应码 200，说明登陆成功。\n带Cookie登陆流程 前端带cookie访问主页 得到 cookie 后，浏览器会请求同域名下的页面（如首页 index.html） 会自动带着 Cookie 。\n后端接收带cookie的请求 后端收到 cookie，得到 SessionID，拿 SessionID 在 Session 哈希表里找到对应的 email，就能知道用户是谁。\n于是根据用户，读取 index.html 文件为字符串，并替换部分内容（本实例是替换密码显示）。\n把替换过部分内容的 index.html 字符串发给前端。\n前端收到替换过部分内容的 index.html 字符串 前端收到这个“针对用户定制”的 index.html 字符串，就能显示用户的个人信息了，如昵称、地址等。\n其他细节 Cookie 访问同一个域名时（同域名，没同源那么严格），都是会自动带上的。\n其实 Session 不是必要的，Cookie 也能直接存用户的 email，Session + SessionID 只是为了给 email 一个中转，中转出一个随机数 SessionID，让客户端无法通过篡改 Cookie 去登陆别人的账户。（email很容易猜，SessionID是随机的很难猜）\ncookie cookie是什么 cookie是服务器发给客户端的一个字符串。\ncookie的流程 前端登陆成功后，后端发送cookie给前端\nresponse.setHeader('Set-Cookie', `sign_in_eamil=${email}`)  以后前端发什么请求都会带上cookie\n服务器收到cookie再分割后，拿它和数据库的账户对比\n再针对该用户的信息，替换针对性的网页内容。\ncookie的特性   服务器通过 set-cookie 头给客户端一串字符串\n  客户端每次访问相同域名的网页时，必须带上这段字符串\n  客户端要在一段时间内保存这个cookie\n  cookie是可以被修改作假的\n  cookie默认有效期20分钟左右，默认在关闭页面后失效，但服务器可以设置 cookie 有效期\n  session session是什么 session是服务器存储的一个哈希表。\n为什么有session 因为cookie直接发送账户email，会被用户修改cookie，登陆其他人的email账户。\n所以我们需要用session+随机数sessionID来存储email，用户只有session，是没办法知道对应的email，更没办法修改session来登陆其他mail了。\nsession的作用 服务器把 sessionID（随机数）通过 cookie 发送给客户端\n客户端访问服务器时，服务器读取 sessionID\n服务器有一块内存（哈希表）保存了所有 session\n通过 sessionID 可以得到对应用户的隐私信息，如账号、email\nsession的缺点 session会占用一定内存。\n本来cookie直接把用户的账号发给客户端，服务器就只需要在数据库存储账号密码就行了。\n使用session后，要用session来存储用户账号，服务器就多存了一份数据，即session。\nsession的特性  服务器将 sessionID（随机数）通过 cookie 发送给客户端 客户端访问服务器时，服务器读取 sessionID 服务器有一块内存（哈希表）保存了所有 session 通过 sessionID 我们可以得到对应用户的隐私信息（账户、email） 这块内存（哈希表）就是服务器上的所有 session  localStorage localStorage是什么 localStorage是浏览器存储的一个哈希表。\nlocalStorage是html5提供的API。\nlocalStorage只能存储字符串。\nlocalStorage的基本API localStorage.setItem('a','1') localStorage.getItem('a') localStorage.clear() localStorage.setItem('jsonString',JSON.stringify({name:'hehe'}))  localStorage的特性  localStorage 跟 HTTP 无关 HTTP 不会带上 localStorage 的值 只有相同域名的页面才能互相读取 localStorage 每个域名 localStorage 最大存储量为 5MB 左右（每个浏览器不一样） 常用场景：记录有没有提示过用户，例如域名搬迁的首次提示。（没有用的信息，不能记录密码） localStorage 永久有效，除非用户清理缓存  sessionStorage sessionStorage的特性  sessionStorage 跟 HTTP 无关 HTTP 不会带上 sessionStorage 的值 只有相同域名的页面才能互相读取 sessionStorage 每个域名 sessionStorage 最大存储量为 5MB 左右（每个浏览器不一样） sessionStorage 在用户关闭页面（会话结束）后就失效  cookie、session、localStorage、sessionStorage的关系  session 一般是通过 cookie 实现的，即服务器通过 cookie 把 sessionID 发给客户端。 localStorage 是跟 HTTP 无关的，访问服务器不会带上 localStorage。sessionStorage同理。 sessionStorage 和 localStorage 差不多，但是 sessionStorage 在关闭页面就失效。  session的2种实现方法 session用cookie的实现方法 服务器把sessionID发cookie请求头。\nresponse.setHeader('Set-Cookie', `sessionId=${sessionId}`)  前端不用发sessionID，因为cookie自带，服务器能收到。\n$.post('/sign_in', hash) .then((response) =\u0026gt; { window.location.href = '/' }, (request) =\u0026gt; { alert('邮箱与密码不匹配') })  session不用cookie的实现方法 服务器直接发sessionID作为响应体\nresponse.write(`sessionId=${sessionId}`)  前端把sessionID存在localStorage，并通过查询参数把sessionID作为请求体发送给服务器。\n$.post('/sign_in', hash) .then((response) =\u0026gt; { let object = JSON.parse(response) localStorage.setItem('sessionId', object.sessionId) window.location.href = `/?sessionId=${object.sessionId}` }, (request) =\u0026gt; { alert('邮箱与密码不匹配') })  服务器通过查询参数获取sessionID\nlet mySession = sessions[query.sessionId]  Cache-Control 缓存控制 同一URL请求，浏览器已经缓存过，就不再发该请求，直接本地加载缓存。\n服务器代码\nif (path === '/main.js') { let string = fs.readFileSync('/main.js', 'utf8') response.setHeader('Content-type', 'application/javascript;charset=utf8') // Cache-Control 缓存控制 response.setHeader('Cache-Control', 'max-age=30') response.statusCode = 200 response.write(string) response.end() }  一般来说，HTML不设置缓存，CSS和JS的缓存时间设置10年。\n服务器要更新CSS和JS的话，修改URL，服务端和前端的URL查询参数加上v=2这样：\nhttp://www.baidu.com/main.js?v=2  Expires 跟 Cache-Control 差不多，时间设置是用格林尼治时间点。\n服务器代码\n// 缓存控制，格林尼治时间2025年前别再请求这个文件 response.setHeader('Expires', 'Wed, 21 Oct 2025 07:28:00 GMT')  Expires 设置的是本地时间点，如果用户本地时间被修改到2026年这样，Expires 就没用了。\nETag 服务器通过ETag响应头发文件的md5给客户端，客户端下次发请求会带上文件的md5，如果md5一致，则不再下载文件，直接从客户端本地读取文件。\nif (path === '/main.js') { let string = fs.readFileSync('/main.js', 'utf8') response.setHeader('Content-type', 'application/javascript;charset=utf8') let fileMd5 = md5(string) // ETag response.setHeader('ETag', 'fileMd5') if (request.headers['if-none-match'] === fileMd5) { response.statusCode = 304 } else { response.write(string) } response.end() }  ETag和Cache-Control的区别在于\nETag要发请求然后判读要不要下载，只响应304，不发响应体。\nCache-Control是直接不请求。\nLast-Modified / If-Modified-Since 在浏览器第一次请求某一个 URL 时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个 Last-Modified 的属性标记此文件在服务期端最后被修改的时间，格式类似这样：\nLast-Modified: Mon, 30 Nov 2015 23:21:37 GMT  \u0008浏览器第二次请求此 URL 时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：\nIf-Modified-Since: Mon, 30 Nov 2015 23:21:37 GMT  如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。\n","id":5,"section":"posts","summary":"从注册登陆实例学习Cookie\\Session\\LocalStorage\\SessionStorage\\Cache-Control\\Expi","tags":["Cookie","Session","LocalStorage","SessionStorage","Cache-Control","Expires","ETag","Last-Modified"],"title":"注册登陆","uri":"https://jaylanwood.github.io/2020/02/%E6%B3%A8%E5%86%8C%E7%99%BB%E9%99%86/","year":"2020"},{"content":"动画与缓动 简介 这是一个前端简单动画和缓动函数的学习记录。\n项目地址 项目地址\n效果预览\n1.页面加载动画 -呼吸 效果预览\n代码\nhtml\n\u0026lt;!-- 加载动画 --\u0026gt; \u0026lt;div class=\u0026quot;webWelcome active\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;loading\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  css\n/* 页面加载动画 */ .webWelcome { display: none; position: fixed; align-items: center; justify-content: center; left: 0; top: 0; width: 100%; height: 100%; background-color: gray; z-index: 10; } .webWelcome.active { display: flex } .webWelcome\u0026gt;.loading, .webWelcome\u0026gt;.loading::after { content: \u0026quot;\u0026quot;; display: block; width: 100px; height: 100px; border-radius: 50%; animation: scale-up-center 1.5s linear infinite; } .webWelcome\u0026gt;.loading::after { animation-delay: 0.75s; } @keyframes scale-up-center { 0% { transform: scale(0); background-color: rgba(0, 0, 0, 1); } 100% { transform: scale(1); background-color: rgba(0, 0, 0, 0); } }  2.自制超链接a的锚点跳转动画 利用setInterval,每一段时间滚动一次窗口。\nhtml\n\u0026lt;section\u0026gt; \u0026lt;a class=\u0026quot;default\u0026quot; href=\u0026quot;#default\u0026quot;\u0026gt;默认的a跳转\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026quot;myAnimation\u0026quot; href=\u0026quot;#myAnimation\u0026quot;\u0026gt;自制的a跳转动画\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026quot;tweenjsAnimation\u0026quot; href=\u0026quot;#tweenjsAnimation\u0026quot;\u0026gt;tweenjs的a跳转缓动动画\u0026lt;/a\u0026gt; \u0026lt;div id=\u0026quot;default\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;myAnimation\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;tweenjsAnimation\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- tween.js --\u0026gt; \u0026lt;script src=\u0026quot;https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  js\n// 1.自制超链接a的锚点跳转动画 let myAnimationaTags = document.querySelector('.myAnimation') myAnimationaTags.onclick = function (xxx) { // 取消a默认的跳转动作 xxx.preventDefault() // 找到a要跳转的目标 let a = xxx.currentTarget let href = a.getAttribute('href') let element = document.querySelector(href) let targetTop = element.offsetTop // 目标高度 let currentTop = window.scrollY // 当前高度 /*** 用setInterval在500毫秒内滚完动画，滚25次 ***/ let n = 25 // 一共滚动25次（500毫秒25次，也就是50帧/s） let duration = 500 / n // 多少时间滚动一次 let distance = (targetTop - currentTop) / n // 每次滚动的距离 let i = 0 let timerID = setInterval(() =\u0026gt; { if (i === n) { window.clearInterval(timerID) return } i = i + 1 window.scrollTo(0, currentTop + distance * i) }, duration) }  3.用tween.js做a跳转的缓动动画 // 2.用tween.js做a跳转的缓动动画 /*** tween.js需要的代码，不用管 ***/ function animate(time) { requestAnimationFrame(animate); TWEEN.update(time); } requestAnimationFrame(animate); /*** tween.js需要的代码，不用管 ***/ let tweenjsAnimationaTags = document.querySelector('.tweenjsAnimation') tweenjsAnimationaTags.onclick = function (xxx) { // 取消a默认的跳转动作 xxx.preventDefault() // 找到a要跳转的目标 let a = xxx.currentTarget let href = a.getAttribute('href') let element = document.querySelector(href) let targetTop = element.offsetTop // 目标高度 let currentTop = window.scrollY // 当前高度 // 用tween.js缓动 let time = Math.abs((targetTop - currentTop) / 100 * 500) if (time \u0026gt; 500) { time = 500 } const coords = { y: currentTop }; // 初始位置 const tween = new TWEEN.Tween(coords) .to({ y: targetTop }, time) // time秒内移动到targetTop .easing(TWEEN.Easing.Quadratic.InOut) // 使用的tween的缓动函数Quadratic.InOut .onUpdate(() =\u0026gt; { window.scrollTo(0, coords.y) // 窗口滚动到coords.y，coords.y是由tween更新的，最后coords.y等于targetTop }) .start(); }  4.tween.js的官方快速上手demo // 3.tween.js的官方快速上手demo // 创建box const box = document.createElement('div'); box.innerText='tween.js官方demo' box.style.setProperty('background-color', '#008800'); box.style.setProperty('width', '100px'); box.style.setProperty('height', '100px'); document.body.appendChild(box); // Setup the animation loop. function animate(time) { requestAnimationFrame(animate); TWEEN.update(time); } requestAnimationFrame(animate); const coords = { x: 0, y: 0 }; // 初始位置(0, 0) const tween = new TWEEN.Tween(coords) // 创建tween .to({ x: 300, y: 200 }, 1000) // 1秒内移动到(300, 200) .easing(TWEEN.Easing.Quadratic.Out) // 使用的tween的缓动函数 .onUpdate(() =\u0026gt; { // 改变box的style添加动画 box.style.setProperty('transform', `translate(${coords.x}px, ${coords.y}px)`); }) .start(); // 启动  ","id":6,"section":"posts","summary":"动画与缓动 简介 这是一个前端简单动画和缓动函数的学习记录。 项目地址 项目地址 效果预览 1.页面加载动画 -呼吸 效果预览 代码 html \u0026lt;!-- 加载动画 --\u0026gt; \u0026lt;div class=\u0026quot;webWelcome active\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;loading\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;","tags":["动画","缓动","tween.js"],"title":"动画与缓动","uri":"https://jaylanwood.github.io/2020/02/%E5%8A%A8%E7%94%BB%E4%B8%8E%E7%BC%93%E5%8A%A8/","year":"2020"},{"content":"LeanCloud 简介 LeanCloud 可以用来做简单文字类的数据库，但是它不能存储文件。\n用途举例：留言板\n数据存储开发指南 · JavaScript\n安装 首先 npm 安装\nnpm install leancloud-storage --save  然后 script 引入\n\u0026lt;script src=\u0026quot;./node_modules/leancloud-storage/dist/av-min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  初始化 首先进入 控制台 \u0026gt; 设置 \u0026gt; 应用 Key 来获取 App ID，App Key 以及服务器地址。\nAV.init({ appId: \u0026quot;XXXXXX\u0026quot;, appKey: \u0026quot;XXXXXX\u0026quot;, serverURLs: \u0026quot;https://xxx.example.com\u0026quot; });  保存对象 // 保存对象 var Message = AV.Object.extend('message'); var message = new Message(); message.set({ name: 'name1', content: 'content1' }); message.save().then(function (message) { console.log('保存成功。内容为：') console.dir(message) }, function (error) { console.log('保存失败。error：' + error) })  保存对象的内容 { \u0026quot;name\u0026quot;: \u0026quot;name1\u0026quot;, \u0026quot;content\u0026quot;: \u0026quot;content1\u0026quot;, \u0026quot;ACL\u0026quot;: { \u0026quot;*\u0026quot;: { \u0026quot;read\u0026quot;: true, \u0026quot;write\u0026quot;: true } }, \u0026quot;objectId\u0026quot;: \u0026quot;5e63ab59546eaa0075b6441c\u0026quot;, \u0026quot;createdAt\u0026quot;: \u0026quot;2020-03-07T14:10:33.031Z\u0026quot;, \u0026quot;updatedAt\u0026quot;: \u0026quot;2020-03-07T14:10:33.031Z\u0026quot; }  获取对象 // 获取对象 var query = new AV.Query('message') query.find().then(function (message) { console.log('获取成功。内容为：') console.dir(message) }, function (error) { console.log('获取失败。error：' + error) })  注意事项 不要泄漏 App ID，App Key 以及 serverURLs，提交 github 前记得把相关内容屏蔽掉。\n例如：\n1.首先，用立即执行函数做一个 avInit.js\n! function () { AV.init({ appId: \u0026quot;XXXXXX\u0026quot;, appKey: \u0026quot;XXXXXX\u0026quot;, serverURLs: \u0026quot;https://xxx.example.com\u0026quot; }); }.call()  2.然后，设置到 .gitignore 文件里。\necho \u0026quot;avInit.js\u0026quot; \u0026gt;\u0026gt; \u0026quot;.gitignore\u0026quot;  ","id":7,"section":"posts","summary":"LeanCloud 简介 LeanCloud 可以用来做简单文字类的数据库，但是它不能存储文件。 用途举例：留言板 数据存储开发指南 · JavaScript 安装 首先 npm 安装 npm install leancloud-storage --save 然后 script 引入 \u0026lt;script src=\u0026quot;./node_modules/leancloud-storage/dist/av-min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 初始化 首先","tags":["数据库","存储"],"title":"LeanCloud","uri":"https://jaylanwood.github.io/2020/02/leancloud/","year":"2020"},{"content":"前端MVC 简介 做一个留言板，分为留言列表、留言添加的提交表单。数据存储使用cleancloud。\n图解 前端MVC简述 前端MVC，是一种设计思想，把代码分成视图(View)、数据(Model)、逻辑(Controller)这3个部分。\n一般来说，View就是HTML的部分，Model就是从服务器获取到的数据，Controller就是其他逻辑部分。\n通过一个留言板功能的例子理解MVC MVC前 index.html\n\u0026lt;section class=\u0026quot;message\u0026quot;\u0026gt; \u0026lt;!-- 留言展示 --\u0026gt; \u0026lt;ul class='messageList'\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;!-- 留言提交 --\u0026gt; \u0026lt;form class=\u0026quot;postMessageForm\u0026quot;\u0026gt; 用户：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt; 内容：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;content\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value='提交'\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 引入leancloud存储服务 --\u0026gt; \u0026lt;script src=\u0026quot;//cdn.jsdelivr.net/npm/leancloud-storage@3.15.0/dist/av-min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 留言功能模块 --\u0026gt; \u0026lt;script src=\u0026quot;message.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  message.js\nlet messageList = document.querySelector('.messageList') let postMessageForm = document.querySelector('.postMessageForm') // 初始化leancloud AV.init({ appId: \u0026quot;xxxxxx\u0026quot;, // 由leancloud提供 appKey: \u0026quot;xxxxxx\u0026quot;, // 由leancloud提供 }); // 读取leancloud var query = new AV.Query('message'); query.find() .then(loadMessage) // 给留言表单绑定保存留言数据到leancloud的事件 bindEvents() /* 封装私有函数 */ function bindEvents() { postMessageForm.addEventListener('submit', function (eee) { eee.preventDefault() // 阻止表单提交默认刷新页面事件 saveMessage() }) } function loadMessage(message) { // 把从leancloud获取的留言，遍历插入到留言列表。 let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` messageList.append(li) }) } function saveMessage() { let name = postMessageForm.querySelector('input[name=name]').value let content = postMessageForm.querySelector('input[name=content]').value // leancloud 提供的保存对象的代码 var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); message.save() .then( // 留言成功提交给leancloud后，把这些新增的留言展示在留言列表上。 function (object) { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` messageList.append(li) postMessageForm.querySelector('input[name=content]').value = '' } ) }  MVC后 message.js\n!function () { var view = document.querySelector('.message') var model = { initAV: function () { AV.init({ appId: \u0026quot;xxxxxx\u0026quot;, // 由leancloud提供 appKey: \u0026quot;xxxxxx\u0026quot;, // 由leancloud提供 }); }, fetch: function () { var query = new AV.Query('message'); return query.find() }, } var controller = { view: null, model: null, init: function (view, model) { this.view = view this.messageList = view.querySelector('.messageList') this.postMessageForm = view.querySelector('.postMessageForm') this.model = model this.model.initAV() this.loadMessage() this.bindEvents() }, loadMessage: function () { this.model.fetch().then( // 把从leancloud获取的留言，遍历插入到留言列表。 (message) =\u0026gt; { let array = message.map((item) =\u0026gt; item.attributes) array.forEach((item) =\u0026gt; { let li = document.createElement('li') li.innerText = `${item.name}:${item.content}` this.messageList.append(li) }) } ) }, bindEvents: function () { this.postMessageForm.addEventListener('submit', (eee) =\u0026gt; { eee.preventDefault() // 阻止表单提交默认刷新页面事件 this.saveMessage() }) }, saveMessage: function () { let content = this.postMessageForm.querySelector('input[name=content]').value let name = this.postMessageForm.querySelector('input[name=name]').value // leancloud 提供的保存对象的代码 var Message = AV.Object.extend('message'); var message = new Message(); message.set('name', name); message.set('content', content); message.save() .then( // 留言成功提交给leancloud后，把这些新增的留言展示在留言列表上。 function (object) { let li = document.createElement('li') li.innerText = `${object.attributes.name}:${object.attributes.content}` let messageList = document.querySelector('#messageList') messageList.appendChild(li) myForm.querySelector('input[name=content]').value = '' } ) }, } controller.init(view, model) }.call()  ","id":8,"section":"posts","summary":"前端MVC 简介 做一个留言板，分为留言列表、留言添加的提交表单。数据存储使用cleancloud。 图解 前端MVC简述 前端MVC，是一种设计思想","tags":["MVC"],"title":"前端MVC","uri":"https://jaylanwood.github.io/2020/02/%E5%89%8D%E7%AB%AFmvc/","year":"2020"},{"content":"立即执行函数、闭包 立即执行函数 立即执行函数，就是为了做一个局部变量。\n!function () { var abc = 100 function hehe() { console.log(abc) } hehe() }.call() // 立即执行实现了局部变量  闭包 闭包，就是有一个数据和一个操作数据的函数，只把函数暴露出来给外面的人使用。\nfunction bibao() { var abc = 100 function hehe() { console.log(abc += 1) } return hehe } var usebibao = bibao() usebibao() // usebibao 接收 bibao() 调用后 返回的 hehe函数，然后 usebibao() 调用 等于 hehe() 调用。 // 于是，闭包把 hehe 函数暴露出去给外面的人使用，外面的人可以通过hehe函数操作变量abc+1，但是却读取不到abc（因为abc是局部变量）。  立即执行函数+闭包 立即执行函数+闭包，就是有一个数据和一个操作数据的函数，把函数挂在window上给外面的人使用。\n!function () { var abc = 100 window.hehe = function () { console.log(abc += 1) } }.call(); // !function (){}.call() 是立即执行函数，是为了做局部变量。 // 变量abc + 使用这个变量的函数 = 闭包 // 闭包的函数赋值给window.hehe，是为了暴露出来给被人使用这个函数。 // 于是，别人能通过window.hehe来操作abc的数据+1，但是却不知道abc的值，实现了隐藏数据的作用。  来看一个例子 崩崩崩.html\n\u0026lt;script src=\u0026quot;充值.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;查询余额.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  充值.js\n!function () { var player = { name: '空中劈叉的清洁工', money: 100 } window.charge = function () { player.money += 1 return player.money } }.call(); // player是局部变量，window.charge是全局变量。  查询余额.js\n!function () { var newMoney = window.charge() console.log(newMoney) }.call(); // 不知道player，但是能操作play的money充值。  为了局部变量而使用立即执行函数 网页要实现模块化\n\u0026lt;script src=\u0026quot;充值.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;查询余额.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  不能使用全局变量\n// 充值.js var player = 'sakura' // 查询余额.js var player = 'mei' // 充值.js 和 查询余额.js 都使用了全局变量 player，它们互相覆盖，冲突了。  要使用局部变量，ES5里只有函数有局部变量\nfunction () { var player = '空中劈叉的清洁工' }.call() // player是局部变量，函数也是匿名函数，完美！  但是 chrome 浏览器 会报错，语法错误，试出来一种方法不报错\n!function () { var player = '空中劈叉的清洁工' }.call() // 在函数前面加!就行  更多解决 chrome浏览器 报语法错误的方法：\n(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来 (function(){alert('我是匿名函数')}) () //用括号把函数包起来 !function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。 +function(){alert('我是匿名函数')}() -function(){alert('我是匿名函数')}() ~function(){alert('我是匿名函数')}() void function(){alert('我是匿名函数')}() new function(){alert('我是匿名函数')}()  为了隐藏数据细节而使用闭包 充值.js\n!function () { var player = { name: '空中劈叉的清洁工', money: 100 } window.charge = function () { player.money += 1 return player.money } }.call(); // 只暴露window.charge，不暴露 player。 // 变量player + 使用这个变量的函数 = 闭包  查询余额.js\n!function () { var newMoney = window.charge() console.log(newMoney) }.call(); // 不知道player，但是能通过window.charge操作player的money充值。  立即执行函数+闭包 总结\n!function () { var player = { name: '空中劈叉的清洁工', money: 100 } window.charge = function () { player.money += 1 return player.money } }.call(); // !function (){}.call() 是立即执行函数，是为了做局部变量。 // 变量player + 使用这个变量的函数 = 闭包 // 闭包的函数赋值给window.charge，是为了暴露出来给被人使用这个函数。 // 于是，别人能通过window.charge来操作player的数据+1，但是却不知道player的值，实现了隐藏数据的作用。  一个著名的面试题 var liList = ul.getElementsByTagName('li') for(var i=0; i\u0026lt;6; i++){ liList[i].onclick = function(){ alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 } }  为什么 alert 的总是 6 呢，因为 i 是贯穿整个作用域的，而不是给每个 li 分配了一个 i。\nalert(i) //这里的i一直在遍历的过程中从0变到5，最后停在5.  那么怎么解决这个问题呢？用立即执行函数给每个 li 创造一个独立作用域即可（当然还有其他办法）：\nvar liList = ul.getElementsByTagName('li') for(var i=0; i\u0026lt;6; i++){ !function(xxx){ liList[xxx].onclick = function(){ alert(xxx) // 0、1、2、3、4、5 } }(i) }  在立即执行函数执行的时候，i 的值被赋值给 xxx，此后 xxx 的值一直不变。\ni 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 xxx 「分别」是 0、1、2、3、4、5。\n","id":9,"section":"posts","summary":"立即执行函数、闭包 立即执行函数 立即执行函数，就是为了做一个局部变量。 !function () { var abc = 100 function hehe() { console.log(abc) } hehe() }.call() // 立即执行实现了局部变量 闭包 闭包，就是有一个","tags":["立即执行函数","闭包"],"title":"立即执行函数、闭包","uri":"https://jaylanwood.github.io/2020/02/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85/","year":"2020"},{"content":"简介 这是一个前端新人的关于请求与响应的笔记。\ngithub 演示\n基础准备 做一个服务器 server.js server.js\nvar http = require('http') var fs = require('fs') var url = require('url') var port = process.argv[2] if (!port) { console.log('请指定端口号。\\n例如：node server.js 8080') process.exit(1) } var server = http.createServer(function (request, response) { var parsedUrl = url.parse(request.url, true) var pathWithQuery = request.url var queryString = '' if (pathWithQuery.indexOf('?') \u0026gt;= 0) { queryString = pathWithQuery.substring(pathWithQuery.indexOf('?')) } var path = parsedUrl.pathname var query = parsedUrl.query var method = request.method /******** 路由代码开始 ********/ console.log('含查询字符串的路径\\n' + pathWithQuery) if (path === '/' || path === '/index.html') { // 1.请求 /index.html 或 /。返回 index.html 文件的字符串 var string = fs.readFileSync('./index.html') response.statusCode = 200 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.end() } else { // 0.请求失败。返回 '请求失败' 字符串。 response.statusCode = 404 response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write('请求失败') response.end() } /******** 路由代码结束 ********/ }) server.listen(port) console.log('监听 ' + port + ' 成功\\n请用浏览器打开 http://localhost:' + port)  运行 server.js\nnode server.js 8080  请求测试\n在地址栏输入 http://localhost:8080，请求的是 / ，返回的是 index.html 文件转成的字符串。 在地址栏输入 http://localhost:8080/hehe，请求的是 /hehe，返回的是 '请求失败' 字符串。  数据库是什么鬼 文件系统是一种数据库\nMySQL 是一种数据库\n只要能长久地存数据，就是数据库\n用文件做一个数据库 money.db 创建 money.db 文件作为数据库\necho \u0026quot;99\u0026quot;\u0026gt;money.db // 创建一个文件money.db，内容为99，作为数据库。  money.db 的内容\n99  index.html 用 \u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp; 占位，等待数据替换。\n\u0026lt;h5\u0026gt;余额\u0026lt;span id=\u0026quot;amount\u0026quot;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt;  服务器接受请求修改数据库并返回响应 server.js 当请求 / 或 index.html 时，读取 money.db 替换到 index.html 的 \u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;。\nif (path === '/' || path === '/index.html') { // 请求 /index.html。返回 index.html 文件的字符串。 var string = fs.readFileSync('./index.html', 'utf8') var amount = fs.readFileSync('./money.db', 'utf8') string = string.replace('\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;', amount) response.setHeader('Content-Type', 'text/html;charset=utf-8') response.write(string) response.statusCode = 200 response.end() }  各种发请求 1.用 form 发请求 用 form 可以发 get 请求，但是会刷新页面或新开页面。\nindex.html\n\u0026lt;h5\u0026gt;余额\u0026lt;span id=\u0026quot;amount\u0026quot;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;form action=\u0026quot;/formpay\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;付款\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;  server.js\nif (path === '/formpay' \u0026amp;\u0026amp; method.toUpperCase() === 'POST') { // 请求 /formpay 且类型是 POST。操作数据库，并返回 'success' 字符串。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.write('formpay success') response.statusCode = 200 response.end() }  浏览器收到 \u0026lsquo;pay success\u0026rsquo; 的字符串，整个页面渲染成只有 \u0026lsquo;pay success\u0026rsquo; 字符串的新页面。此时，后退到 index.html 并刷新，会请求 index.html 读取到新的余额。\n用 iframe 接收 form 得到的响应页面 form 默认会在新页面展示接收到的 \u0026lsquo;pay success\u0026rsquo; 字符串。\n我们用 iframe 来展示，就不用跳转页面了。（注意：firefox可以，但chrome还是会跳转）\n\u0026lt;h5\u0026gt;余额\u0026lt;span id=\u0026quot;amount\u0026quot;\u0026gt;\u0026amp;\u0026amp;\u0026amp;amount\u0026amp;\u0026amp;\u0026amp;\u0026lt;/span\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;form action=\u0026quot;/pay\u0026quot; method=\u0026quot;POST\u0026quot; target=\u0026quot;result\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;付款\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe id=\u0026quot;result\u0026quot; src=\u0026quot;about:blank\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;  但是余额上的数字还是没法更新，因为数据库变了，但是当前页面没有请求并接收到新的数据库。\n2.用 a 发请求 用 a 可以发 get 请求，但是会刷新页面或新开页面。\nindex.html\n\u0026lt;a href=\u0026quot;/apay\u0026quot;\u0026gt;用a发请求\u0026lt;/a\u0026gt;  server.js\nif (path === '/apay') { // 请求 /apay。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.write('apay success') response.statusCode = 200 response.end() }  3.用 img 发 get 请求 用 img 可以发 get 请求，可以局部刷新，但是只能以图片的形式展示。\nindex.html\n//点击按钮，生成一个 img，img 的 src 发起 get 请求。 imgButton.addEventListener('click', (e) =\u0026gt; { let image = document.createElement('img') image.src = '/imgpay' image.onload = function () { alert('img成功') // window.location.reload() // 1.成功后帮用户刷新页面 amount.innerText = amount.innerText - 1 // 2.直接局部修改余额 } image.onerror = function () { alert('img失败') } })  server.js\n//接收请求，操作数据库，返回图片、状态码、header。 if (path === '/imgpay') { // 请求 /imgpay。操作数据库，并返回图片。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.setHeader('Content-Type', 'images/jpg') response.write(fs.readFileSync('./success.jpg')) response.statusCode = 200 response.end() }  4.用 link 发请求 用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示。\nindex.html\nlinkpay.onclick = function () { var link = document.createElement('link') link.rel = 'stylesheet' link.href = '/linkpay' document.head.appendChild(link) }  server.js\nif (path === '/linkpay') { // 请求 /linkpay。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.write('apay success') response.statusCode = 200 response.end() }  5.用 script 发 get 请求 用 script 可以发 get 请求，局部刷新，只能 get 不能 post，但是只能以脚本的形式运行。\nindex.html\nscriptButton.addEventListener('click', (e) =\u0026gt; { let script = document.createElement('script') script.src = '/scriptpay' document.body.appendChild(script) script.onload = function (e) { // 状态码是 200~299 则表示成功 alert('scriptpay success') e.currentTarget.remove() // 把服务器返回的 JS 标签移除。 } script.onerror = function (e) { // 状态码大于等于 400 则表示失败 alert('scriptpay fail') e.currentTarget.remove() } })  server.js\nif (path === '/scriptpay') { // 请求 /scriptpay。操作数据库，并返回 script 语法的字符串。 var amount = fs.readFileSync('./money.db', 'utf8') amount -= 1 fs.writeFileSync('./money.db', amount) response.setHeader('Content-Type', 'application/javascript') response.write(` amount.innerText = amount.innerText - 1 `) response.statusCode = 200 response.end() }  浏览器收到复符合 JavaScript 语法的字符串，会执行它。\namount.innerText = amount.innerText - 1 // 假设之前是99，付款后数据库是98。  跨域 SRJ 这种技术叫做 SRJ - Server Rendered JavaScript，服务器返回的 JavaScript。\nJavaScript 是可以跨域的 例如：在我们的网页引用 CDN 的 jQuery，我们的域名肯定跟 cdn.bootcss.com 这个域名不同啊！\n\u0026lt;script src=\u0026quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  6.JSONP 跨域发请求 index.html\nJSONPButton.addEventListener('click', (e) =\u0026gt; { // 1.创建script var script = document.createElement('script') // 2.创建随机字符串 var functionName = 'jaylan' + parseInt(Math.random() * 10000000, 10) // 3.创建一个函数 window[functionName] = function (JSONStr) { amount.innerText = amount.innerText - 1 alert(JSONStr) } // 4.用 script 发起请求。请求路径是 /JSONPpay，请求的查询参数是 callback=functionName。 script.src = '/JSONPpay?callback=' + functionName // 5.把 script 插入 body，使得 script 生效执行。 document.body.appendChild(script) script.onload = function (e) { // 状态码是 200~299 则表示成功 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 } script.onerror = function (e) { // 状态码大于等于 400 则表示失败 e.currentTarget.remove() delete window[functionName] // 请求完了就干掉这个随机函数 } })  server.js\nif (path === '/jQueryJSONPpay') { // 请求 /jQueryJSONPpay。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) let callback = query.callback response.setHeader('Content-Type', 'application/json') response.write(` ${callback}.call(undefined, { \u0026quot;success\u0026quot;:true, \u0026quot;left\u0026quot;:${newAmount} }) `) response.statusCode = 200 response.end()  JSONP 到底干了什么 浏览器做了一个 functionName 的函数， 用 script 发起 /JSONPpay?callback=functionName 的请求。\n服务器收到这个请求，得到了 functionName 的函数名。服务器把 functionName.call(undefined, JSON) 这样的符合 JavaSCript 语法的字符串返回给浏览器。\n浏览器收到返回的字符串，就执行 JavaScript，于是把 functionName 给 call 调用了。\nJSONP的意义 JSONP 实现了：\n前端做了一个函数，这个函数需要一个数据。\n后端把需要的数据做成 JSON对象，并且做成调用这个函数的语句，返回给前端。\n前端拿到语句，调用了函数。\nJSONP为什么不能用POST 因为 JSONP 是通过动态创建 script 实现的，而 script 只能发 get 不能发 post。\n通过jQuery来使用JSONP更方便 // 使用JSONP。jQuery把JSONP归类在ajax，不用在意。 $.ajax({ url: \u0026quot;http://localhost:8888/jQueryJSONPpay\u0026quot;, jsonp: \u0026quot;callback\u0026quot;, dataType: \u0026quot;jsonp\u0026quot;, // 请求的 JSON 内容 // data: { // q: \u0026quot;select title,abstract,url from search.news where query=\\\u0026quot;cat\\\u0026quot;\u0026quot;, // format: \u0026quot;json\u0026quot; // }, // 请求成功后执行的函数 success: function (response) { if (response.success) { amount.innerText = amount.innerText - 1 } } })  7.用XMLHttpRequest发请求 XML响应 用 XMLHttpRequest 发请求，响应回 XML 语法的字符串，解析 XML 当作 DOM 来用。\nindex.html\nXMLpay.addEventListener('click', (e) =\u0026gt; { // 1.构造 XMLHttpRequest 请求 let request = new XMLHttpRequest() // 2.监控请求的状态变化 request.onreadystatechange = () =\u0026gt; { if (request.readyState === 4) { // 状态4===响应完毕 if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300) { console.log('请求成功') // 把xml转化为dom let parser = new DOMParser() let xmlDoc = parser.parseFromString(request.responseText, \u0026quot;text/html\u0026quot;) // 用dom一样来操作xml let heading = xmlDoc.getElementsByTagName('heading')[0].textContent console.log('打印响应xml的heading内容：' + heading) } else if (request.status \u0026gt;= 400) { console.log('请求失败') } } } // 3.配置请求 request.open('GET', './XMLpay') // 4.发送请求 request.send() })  sercer.js\nif (path === '/XMLpay') { // 请求 /XMLpay。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.statusCode = 200 response.setHeader('Content-Type', 'text/xml;charset=utf-8') // XML语法的字符串 response.write(` \u0026lt;note\u0026gt; \u0026lt;to\u0026gt;sakura\u0026lt;/to\u0026gt; \u0026lt;form\u0026gt;jaylan\u0026lt;/form\u0026gt; \u0026lt;heading\u0026gt;welcome\u0026lt;/heading\u0026gt; \u0026lt;body\u0026gt;bengbengbeng\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt; `) response.end() }  8.用XMLHttpRequest发请求 JSON响应 响应 XML 太麻烦了，不好用，于是用 JSON 代替 XML，JSON 是轻量级的数据交换语言。\nindex.html\n// 1.构造 XMLHttpRequest 请求 let request = new XMLHttpRequest() // 2.监控请求的状态变化 request.onreadystatechange = () =\u0026gt; { if (request.readyState === 4) { // 状态4===响应完毕 if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300) { console.log('请求成功') let string = request.responseText // 把符合 JSON 语法的字符串，转换成 JS 对应的值。 let object = window.JSON.parse(string) // JSON.parse 是浏览器提供的 console.log(typeof object) console.log(object) } else if (request.status \u0026gt;= 400) { console.log('请求失败') } } } // 3.配置请求 request.open('GET', './JSONpay') // 4.发送请求 request.send()  readyState请求的5种状态\n   值 状态 描述     0 UNSENT 代理被创建，但尚未调用 open() 方法。   1 OPENED open() 方法已经被调用。   2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。   3 LOADING 响应下载中； responseText 属性已经包含部分数据。   4 DONE 响应下载操作已完成。    server.js\nif (path === '/JSONpay') { // 请求 /JSONpay。 var amount = fs.readFileSync('./money.db', 'utf8') var newAmount = amount - 1 fs.writeFileSync('./money.db', newAmount) response.statusCode = 200 response.setHeader('Content-Type', 'text/json;charset=utf-8') // response.setHeader('Access-Control-Allow-Origin', 'http://localhost:8888/') // JSON语法的字符串 response.write(`{ \u0026quot;note\u0026quot;:{ \u0026quot;to\u0026quot;:\u0026quot;八重樱\u0026quot;, \u0026quot;from\u0026quot;:\u0026quot;飞鱼丸\u0026quot;, \u0026quot;heading\u0026quot;:\u0026quot;嘤嘤嘤\u0026quot;, \u0026quot;body\u0026quot;:\u0026quot;大姐你回来啦\u0026quot; } }`) response.end() }  JavaScript 与 JSON   JSON 没有 function 和 undefined。\n  JSON 的字符串首尾必须是双引号\u0026rdquo;。\n     JavaScript JSON     undefined 没有   null null   [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;] [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]   function fn(){} 没有   {name:\u0026lsquo;sakura\u0026rsquo;} {\u0026ldquo;name\u0026rdquo;:\u0026ldquo;sakura\u0026rdquo;}   \u0026lsquo;sakura\u0026rsquo; \u0026ldquo;sakura\u0026rdquo;   var a = {} a.self = a 没有变量   {__proto__} 没有原型链    JSON官网\n9.用AJAX发请求 index.html\nAJAXpay.addEventListener('click', (e) =\u0026gt; { let request = new XMLHttpRequest() request.onreadystatechange = () =\u0026gt; { if (request.readyState === 4) { if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300) { successFn.call(undefined, arg) } else if (request.status \u0026gt;= 400) { failFn.call(undefined.arg) } } } request.open('GET', './AJAXpay') request.send() })  什么是AJAX AJAX不是JavaScript的规范，它只是一个哥们Jesse James Garrett“发明”的缩写：\nAsynchronous JavaScript and XML\n异步的 JavaScript 和 XML\n意思就是用JavaScript执行异步网络请求。\n用JavaScript发请求，用JavaScript处理响应。\n  使用XMLHttpRequest发请求。\n  服务器返回符合XML格式的字符串。\n  JS解析XML，并更新局部页面。\n  因为XML不好用，后来人们用JSON替代了XML。\n  金句：\n 你才返回对象，你全家都返回对象 JS 是一门语言，JSON 是另一门语言，JSON 这门语言抄袭了 JS这门语言 AJAX 就是用 JS 发请求 响应的第四部分是字符串，可以用 JSON 语法表示一个对象，也可以用 JSON 语法表示一个数组，还可以用 XML 语法，还可以用 HTML 语法，还可以用 CSS 语法，还可以用 JS 语法，还可以用我自创的语法  只有 AJAX 要同源策略，其他 a\\img\\form\\link\\script 都可以跨源。 只有 协议+端口+域名 一模一样才允许发 AJAX 请求\n一模一样一模一样一模一样一模一样一模一样一模一样一模一样一模一样\n http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗 no http://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗 no  浏览器必须保证 只有 协议+端口+域名 一模一样才允许发 AJAX 请求 CORS 可以告诉浏览器，我俩一家的，别阻止他\n突破同源策略 === 跨域\nCORS 跨域 Cross-Origin Resource Sharing\nserver.js\n// CORS 跨源共享给http://frank.com:8001 response.setHeader('Access-Control-Allow-Origin', 'http://frank.com:8001')  AJAX 的所有功能  客户端的JS发起请求（浏览器上的） 服务端的JS发送响应（Node.js上的）  JS 可以设置任意请求 header\n第一部分 request.open('get', '/xxx') 第二部分 request.setHeader('content-type','x-www-form-urlencoded') 第四部分 request.send('a=1\u0026amp;b=2')  JS 可以获取任意响应 header\n第一部分 request.status / request.statusText 第二部分 request.getResponseHeader() / request.getAllResponseHeaders() 第四部分 request.responseText  10.自制 window.jQuery.ajax window.jQuery.ajax = function (options) { // 代码 }  AJAX 的回调 window.myQuery.ajax = function ({url,method,body,successFn,failFn,}) { let request = new XMLHttpRequest() request.open(method, url) request.onreadystatechange = () =\u0026gt; { if (request.readyState === 4) { if (request.status \u0026gt;= 200 \u0026amp;\u0026amp; request.status \u0026lt; 300) { // request.onreadystatechange 触发时，call successFn successFn.call(undefined, request.responseText) } else if (request.status \u0026gt;= 400) { failFn.call(undefined, request) } } } request.send(body) } // 使用方代码 myQAJAX.addEventListener('click', (e) =\u0026gt; { window.myQuery.ajax({ url: '/xxx', method: 'post', body: 'a=1\u0026amp;b=2', // 使用方写的函数，使用方不call successFn: (responseText) =\u0026gt; { console.log(1) }, failFn: (request) =\u0026gt; { console.log(2) } }) }) // myQAJAX 按钮按下，调用 ajax()，写了一个 successFn 函数，但是它没调用。 // request.onreadystatechange 监听变化，触发 successFn.call。 // successFn:() =\u0026gt;{} 这个函数就是回调函数。  同步、异步、回调 同步：一定要等任务执行完了，得到结果，才执行下一个任务。\nfunction taskSync() { return '同步任务的返回值' } var result = taskSync() // 那么 result 就是同步任务的结果 otherTask() // 然后执行下一个任务  异步：不等任务执行完，直接执行下一个任务。\nfunction taskAsync() { var result = setTimeout(function () { console.log('异步任务的结果') }, 3000) return result // 返回 setTimeout 的 TimerID } var result = taskAsync() // result 不是异步任务的结果，而是一个 timer id otherTask() // 立即执行其他任务，不等异步任务结束  聪明的你可能会发现，我们拿到的 result 不是异步执行的结果，而是一个 timer id，那么要怎么拿到异步任务的结果呢？\n用回调。\n改下代码如下：\nfunction taskAsync(callback) { var result = setTimeout(function () { callback('异步任务的结果') }, 3000) return result } function callback(result) { console.log(result) // 三秒钟后，这个 callback 函数会被执行 } taskAsync.call(callback) // taskAsync 来调用 otherTask() // 立即执行其他任务，不等异步任务结束  所以「回调」经常用于获取「异步任务」的结果。\n回调的问题 问题是每个程序员的回调名不一样\nPromise 解决了这个问题 请背下这个代码\nfunction xxx() { return new Promise((f1, f2) =\u0026gt; { doSomething() setTimeout(() =\u0026gt; { // 成功就调用 f1，失败就调用 f2 }, 3000) }) } xxx().then(success, fail) // 链式操作 xxx().then(success, fail).then(success, fail)  ES6的解构赋值 解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。\nlet a = obj.a let b = obj.b let c = obj.c // 等价于下面的这行代码。ES6 解构赋值。 let{a,b,c}= obj  var a = 'a'; var b = 'b'; [a, b] = [b, a] // 交换变量 a b 的值。  ","id":10,"section":"posts","summary":"简介 这是一个前端新人的关于请求与响应的笔记。 github 演示 基础准备 做一个服务器 server.js server.js var http = require('http') var fs = require('fs') var url = require('url') var port = process.argv[2] if (!port) { console.log('请","tags":["请求","异步","回调","Promise","解构赋值","JSONP","AJAX"],"title":"请求、异步、回调、Promise、解构赋值","uri":"https://jaylanwood.github.io/2020/01/%E8%AF%B7%E6%B1%82%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83promise%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","year":"2020"},{"content":"DOM 事件 事件监听函数 HTML 的 on 属性 实例 \u0026lt;button onclick='alert(123)'\u0026gt;\n\u0026lt;button onclick=\u0026quot;alert('123')\u0026quot;\u0026gt;\u0026lt;/button\u0026gt;  语法 \u0026lt;button onclick=\u0026quot;函数名()\u0026quot;\u0026gt;\u0026lt;/button\u0026gt;  细节 on 属性的值原样传入 JS 引擎执行，不要忘了加圆括号执行 \u0026lt;!-- on 属性的值原样传入 JavaScript 引擎执行，不要忘了加圆括号执行。 --\u0026gt; \u0026lt;!-- 正确 --\u0026gt; \u0026lt;div onload=\u0026quot;doSomething()\u0026quot;\u0026gt; \u0026lt;!-- 错误 --\u0026gt; \u0026lt;div onload=\u0026quot;doSomething\u0026quot;\u0026gt;  on 只在冒泡阶段触发 先儿子后爸爸  \u0026lt;!-- 只在冒泡阶段触发。先 儿子 后 爸爸 --\u0026gt; \u0026lt;div onClick=\u0026quot;alert('爸爸')\u0026quot;\u0026gt; \u0026lt;button onClick=\u0026quot;alert('儿子')\u0026quot;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;  元素节点的 setAttribute 方法设置 on 属性，效果是一样的 \u0026lt;!-- 元素节点的setAttribute方法设置on属性，效果是一样的。 --\u0026gt; \u0026lt;script\u0026gt;abc.setAttribut(\u0026quot;onclick\u0026quot;, \u0026quot;console.log('hi!')\u0026quot;)\u0026lt;/script\u0026gt; \u0026lt;!-- 等同于 --\u0026gt; \u0026lt;div id=\u0026quot;abc\u0026quot; onclick=\u0026quot;console.log('hi!')\u0026quot;\u0026gt;  元素节点对象的 on 事件属性 语法 // 元素节点的 on 属性值是函数名，不用括号。 button.onlick = doSomething; button.onclick = function (event) { alert('元素节点对象的 on'); };  Node 对象的 addEventListener 方法 语法 target.addEventListener(type, listener, useCapture) // 目标对象.addEventListener(事件类型,监听函数,捕获布尔值) // useCapture 是指要在捕获阶段还是冒泡阶段触发，默认值 false 是冒泡阶段触发。  细节 // addEventListener 的事件尊许队列的先进先出特性。 btn.addEventListener('click',function(){}) // 同一事件多次添加同一个监听函数，该函数只会执行一次。 function fn1() {alert('123')} target1.addEventListener('click', fn1) target1.addEventListener('click', fn1) // 同一事件（click），同一监听函数（fn1），上面只 alert 一次。  \u0026lt;div onclick='fn()'\u0026gt; 和 div.onclick=function(){} 和 `div.addEventListener(\u0026lsquo;click\u0026rsquo;,function() \u0026lt;div onclick='fn()'\u0026gt;违反了 HTML 和 JS 的分离原则。\ndiv.onclick=function(){} 不能添加个 onclick，前一个会被后一个覆盖。\ndiv.addEventListener('click',function(){}) 可以添加多个 click，可以指定捕获还是冒泡触发，是整个 JavaScript 统一的监听函数接口。\n事件传播 图示与语法 事件传播（propagation），捕获阶段（capture phase）、目标阶段（target phase）、冒泡阶段（bubbling phase）\ngrand1.addEventListener('click', function () { console.log('爷爷') }, false) parent1.addEventListener('click', function () { console.log('爸爸') }, false) child1.addEventListener('click', function () { console.log('儿子') }, false) // 捕获阶段：爷爷 -\u0026gt; 爸爸 -\u0026gt; 儿子 // 冒泡阶段：儿子 -\u0026gt; 爸爸 -\u0026gt; 爷爷 // 目标阶段：儿子是同时存在 捕获 和 冒泡 的，不分顺序。只按照代码顺序执行。 // 第3个参数是 false，儿子爸爸爷爷。 // 第3个参数是 true，爷爷爸爸儿子。 // 不传第3个useCapture参数，即默认是 false，在冒泡阶段触发函数。  目标阶段，不分顺序，只按照代码顺序执行。 child1.addEventListener('click', function () { console.log('儿子捕获') }, true) child1.addEventListener('click', function () { console.log('儿子冒泡') }, false) // 儿子捕获 - 儿子冒泡 child1.addEventListener('click', function () { console.log('儿子冒泡') }, false) child1.addEventListener('click', function () { console.log('儿子捕获') }, true) // 儿子冒泡 - 儿子捕获  阻止事件传播 // 事件捕获到 爸爸 后，就不再向 儿子 传播了。但是 爸爸 本身的函数还是能执行的。 parent1.addEventListener('click', function (event) { event.stopPropagation(); console.log('爸爸') }, true); // 事件冒泡到 爸爸 后，就不再向 爷爷 传播了。但是 爸爸 本身的函数还是能执行的。 parent1.addEventListener('click', function (event) { event.stopPropagation(); console.log('爸爸') }, false);  事件的代理 利用冒泡，把儿子们的监听函数定义在爸爸上，就是事件的代理（delegation）。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;  var ul = document.querySelector('ul'); ul.addEventListener('click', function (event) { if (event.target.tagName.toLowerCase() === 'li') { // some code } });  如何做「点击其他地方关闭浮层」 需求 点击按钮出现浮层，浮层和按钮不会冒泡到父元素，点击别处关闭浮层。\n实现 HTML \u0026lt;div id=\u0026quot;wrapper\u0026quot;\u0026gt; \u0026lt;button id=\u0026quot;clickMe\u0026quot;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026quot;popover\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;checkbox\u0026quot;\u0026gt;浮层\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;  方案一 // 监听按钮，点击显示浮层。 $(clickMe).on('click', function () { $(popover).show() }) // 阻止 按钮+浮层 冒泡。 $(wrapper).on('click', function (e) { e.stopPropagation() }) // 监听 document，隐藏浮层。 $(document).on('click', function () { $(popover).hide() })  缺点：一直监听 document，如果页面每个按钮都添加一个 document 监听，太浪费内存。\n方案一改进 // 监听按钮，点击显示浮层。 $(clickMe).on('click', function () { $(popover).show() // 监听一次 document，document 被点击后监听销毁，很节省内存。 $(document).one('click', function () { $(popover).hide() }) }) // 阻止 按钮+浮层 冒泡。 $(wrapper).on('click', function (e) { e.stopPropagation() })  方案二 $(clickMe).on('click', function () { $(popover).show() $(document).one('click', function () { $(popover).hide() }) }) // 把阻止冒泡去掉，为什么浮层点不出来？ // 不是应该浮层出现，才监听 document，不会触发 document 的点击么？ // 因为点击按钮后，目标阶段 触发 浮层显示 + document监听，然后在冒泡阶段把 document监听 执行了。  缺点：浮层点不出来\n方案二改进 $(clickMe).on('click', function() { $(popover).show() setTimeout(function() { $(document).one('click', function() { $(popover).hide() }) }, 0) }) // 用 setTimeout 让 document监听 延迟执行。让 document监听 在冒泡阶段后才执行。  ","id":11,"section":"posts","summary":"DOM 事件 事件监听函数 HTML 的 on 属性 实例 \u0026lt;button onclick='alert(123)'\u0026gt; \u0026lt;button onclick=\u0026quot;alert('123')\u0026quot;\u0026gt;\u0026lt;/button\u0026gt; 语法 \u0026lt;button onclick=\u0026quot;函数名()\u0026quot;\u0026gt;\u0026lt;/button\u0026gt; 细节 on","tags":["事件","DOM"],"title":"DOM事件","uri":"https://jaylanwood.github.io/2020/01/dom%E4%BA%8B%E4%BB%B6/","year":"2020"},{"content":"博客图床怎么弄 图床怎么搞定 hugo博客算是搭好了，主题也换了。\n目前还挺满意，可是图床却挺烦的。\n国内的服务商，七牛是挺多人推荐的，但是要备案，https 还要收费。穷啊～\n国外的首先就想到 github，毕竟免费，有戏，搞起来！\nPicGo + GitHub 图床 核心思路：  新建一个 github 仓库，专门用来上传图床。 一个专门用来上传图床的工具，不然手动 commit 要累死人。 新建一个 token 专门给图床工具用。  实现方案： PicGo + GitHub 图床\n参考文章： 图床上传工具PicGo\n最终结果 体验很不错，只是图片不算私有，若没梯子有时会很慢。\n","id":12,"section":"posts","summary":"博客图床怎么弄 图床怎么搞定 hugo博客算是搭好了，主题也换了。 目前还挺满意，可是图床却挺烦的。 国内的服务商，七牛是挺多人推荐的，但是要备案，","tags":["hugo"],"title":"博客图床怎么弄","uri":"https://jaylanwood.github.io/2020/01/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E6%80%8E%E4%B9%88%E5%BC%84/","year":"2020"},{"content":"轮播总结 轮播1 - 普通轮播 效果需求  图片切换。 点击按钮切换到指定图片。 自动播放。 鼠标移入暂停自动播放，鼠标移出继续自动播放。 当前图片对应的按钮高亮红色显示。   最终代码 GitHub\n 核心原理  图片横排组成一个 images。 一个窗口展示一张图片，用 overflow:hidden 把超出的图片隐藏掉。 images 通过 margin-left 或者 transform: translate 来改变位置。  // 点击按钮 切换图片 function listenToButton() { for (let i = 0; i \u0026lt; buttons.length; i++) { $(buttons[i]).on('click', function (xxx) { var index2 = $(xxx.currentTarget).index() var n = index2 * -300 // 切换图片 images.css({ transform: 'translateX(' + n + 'px)' }) // 按钮高亮 $(buttons[index2]).addClass('red') .siblings().removeClass('red') // 更改 自动点击按钮 的 index 为 被按下按钮的 i index = i }) } }   轮播2 - 跳绳的无缝轮播 效果需求 轮播1不是无缝的，我要做个无缝轮播。\n最终代码 GitHub\n核心原理 像跳绳一样，等待、进去、出来，循环如此。\n第一张进入离开区，当第一张离开后，马上又进入等待区。\n当第一张离开后，第二张进入展示区。\n.images { position: relative; } .images\u0026gt;.img { position: absolute; width: 100%; top: 0; transition: all 1s } /* 展示区 */ .images\u0026gt;.img.current { transform: translatex(0); z-index: 1; } /* 离开区 */ .images\u0026gt;.img.leave { transform: translatex(-100%); } /* 等待区 */ .images\u0026gt;.img.enter { transform: translatex(100%); }  // 切换状态 function makeCurrent($node) { return $node.removeClass('enter leave').addClass('current') } function makeLeave($node) { return $node.removeClass('enter current').addClass('leave') } function makeEnter($node) { return $node.removeClass('current leave').addClass('enter') } // 自动无缝轮播 let timer = setInterval(() =\u0026gt; { makeLeave(getImg(n)) .one('transitionend', (xxx) =\u0026gt; { makeEnter($(xxx.currentTarget)) }) makeCurrent(getImg(n + 1)) n += 1 }, 2000); // 初始化 function initN(startIndex) { n = startIndex $('.images\u0026gt;img:nth-child(' + n + ')').addClass('current') .siblings().addClass('enter') } initN(1)   轮播3 - 偷梁换柱的无缝轮播 效果需求   首尾切换无缝\n  上/下一张\n  点击按钮跳转到某一张\n  自动轮播\n  鼠标移入（移出）实现暂停（播放）\n   最终代码 Github\n 核心原理 先切到首尾假图，瞬间切回真图。\n真3 --\u0026gt; 假1 --\u0026gt; 真1\n\u0026lt;img src=\u0026quot;./img/3.png\u0026quot; alt=\u0026quot;图片3\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./img/1.png\u0026quot; alt=\u0026quot;图片1\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./img/2.png\u0026quot; alt=\u0026quot;图片2\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./img/3.png\u0026quot; alt=\u0026quot;图片3\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;./img/1.png\u0026quot; alt=\u0026quot;图片1\u0026quot;\u0026gt;  // 普通切图 function normalSlide(index, time) { return $imagesWrapper.css({ transform: `translateX(${-(index+1)*300}px)`, transition: `all ` + time }) } // 首尾切图 function fakeSlide(fakeImgIndex, index, time) { // 1.先切去假图 normalSlide(fakeImgIndex, time).one('transitionend', function () { // 2.一旦动画完成，马上隐藏 $imagesWrapper.hide().offset() // offset，重新算位置，打断浏览器的 hide 和 show 合并。 // 3.瞬间切到真图，并显示出来 normalSlide(index, '0s').show() }) } // 根据 当前图片current 和 目标图片index，判断 普通切图 和 首尾切图 function goToSlides(index) { // 判断真正要去的 index if (index \u0026gt; $buttons.length - 1) { index = 0 } else if (index \u0026lt; 0) { index = $buttons.length - 1 } if (current === $buttons.length - 1 \u0026amp;\u0026amp; index === 0) { let fakeImgIndex = current + 1 fakeSlide(fakeImgIndex, index, '1s') } else if (current === 0 \u0026amp;\u0026amp; index === $buttons.length - 1) { let fakeImgIndex = current - 1 fakeSlide(fakeImgIndex, index, '1s') } else { normalSlide(index, '1s') } current = index }   其他细节  上/下一张 goToSlides(current - 1) goToSlides(current + 1)  自动轮播 function autoPlay() { timerID = setInterval(() =\u0026gt; { goToSlides(current + 1) }, 2000) }  点击按钮跳转某一张 function bindButtons() { $('.buttonsWrapper').on('click', 'button', function (xxx) { goToSlides($(xxx.currentTarget).index()) }) }  鼠标移入（移出）实现暂停（播放） $('.window').on('mouseenter', function () { stopPlay() }).on('mouseleave', function () { autoPlay() })  把假的第一张和最后一张做出来插入images // 把 HTML 的假图片删掉，用 JS 来生成插入。 function makeFakeImg() { let $imgs = $('.imagesWrapper img') let fristClone = $imgs.eq(0).clone(true) let latClone = $imgs.eq($imgs.length - 1).clone(true) $('.imagesWrapper').append(fristClone).prepend(latClone); }   轮播4 - Apple 产品轮播展示 项目地址\n预览地址\n","id":13,"section":"posts","summary":"轮播总结 轮播1 - 普通轮播 效果需求 图片切换。 点击按钮切换到指定图片。 自动播放。 鼠标移入暂停自动播放，鼠标移出继续自动播放。 当前图片对应的按钮高","tags":["轮播"],"title":"轮播总结","uri":"https://jaylanwood.github.io/2020/01/%E8%BD%AE%E6%92%AD%E6%80%BB%E7%BB%93/","year":"2020"},{"content":"纪念我的第一个hugo博客的诞生 Hello World 才刚搭起第一个博客，想不到写啥，那就先来句 Hello World 吧。\nconsole.log('Hello World')  记录hugo博客搭建的过程  安装 hugo  brew install hugo  新建一个 myblog 网站  hugo new site blog cd blog/  安装主题  git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure  新建一篇博客文章  hugo new posts/blog1.md  本地 server 测试  hugo server -D 或者 hugo server -t 主题名 --buildDrafts  生成静态网站到 public 目录  hugo -D 或者 hugo --theme=pure --baseUrl=\u0026quot;https://jaylanwood.github.io/\u0026quot; --buildDrafts  把博客部署到 github  git init git add . git commit -m \u0026quot;我的hugo博客\u0026quot; git remote add origin git@github.com:JaylanWood/jaylanwood.github.io.git git push -u origin master  测试部署结果，浏览器打开 jaylanwood.github.io  ","id":14,"section":"posts","summary":"纪念我的第一个hugo博客的诞生 Hello World 才刚搭起第一个博客，想不到写啥，那就先来句 Hello World 吧。 console.log('Hello World') 记录hugo博客搭建的过程 安装 hugo brew install hugo 新建一个 myblog 网","tags":["hugo"],"title":"纪念我的第一个博客的诞生","uri":"https://jaylanwood.github.io/2020/01/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/","year":"2020"}],"tags":[{"title":"AJAX","uri":"https://jaylanwood.github.io/tags/ajax/"},{"title":"Cache-Control","uri":"https://jaylanwood.github.io/tags/cache-control/"},{"title":"Cookie","uri":"https://jaylanwood.github.io/tags/cookie/"},{"title":"DOM","uri":"https://jaylanwood.github.io/tags/dom/"},{"title":"ETag","uri":"https://jaylanwood.github.io/tags/etag/"},{"title":"Expires","uri":"https://jaylanwood.github.io/tags/expires/"},{"title":"Fresnel","uri":"https://jaylanwood.github.io/tags/fresnel/"},{"title":"HTML","uri":"https://jaylanwood.github.io/tags/html/"},{"title":"hugo","uri":"https://jaylanwood.github.io/tags/hugo/"},{"title":"JSONP","uri":"https://jaylanwood.github.io/tags/jsonp/"},{"title":"Last-Modified","uri":"https://jaylanwood.github.io/tags/last-modified/"},{"title":"LocalStorage","uri":"https://jaylanwood.github.io/tags/localstorage/"},{"title":"Metalness","uri":"https://jaylanwood.github.io/tags/metalness/"},{"title":"MVC","uri":"https://jaylanwood.github.io/tags/mvc/"},{"title":"PBR","uri":"https://jaylanwood.github.io/tags/pbr/"},{"title":"Promise","uri":"https://jaylanwood.github.io/tags/promise/"},{"title":"Session","uri":"https://jaylanwood.github.io/tags/session/"},{"title":"SessionStorage","uri":"https://jaylanwood.github.io/tags/sessionstorage/"},{"title":"tween.js","uri":"https://jaylanwood.github.io/tags/tween.js/"},{"title":"事件","uri":"https://jaylanwood.github.io/tags/%E4%BA%8B%E4%BB%B6/"},{"title":"动画","uri":"https://jaylanwood.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"title":"发展史","uri":"https://jaylanwood.github.io/tags/%E5%8F%91%E5%B1%95%E5%8F%B2/"},{"title":"回调","uri":"https://jaylanwood.github.io/tags/%E5%9B%9E%E8%B0%83/"},{"title":"存储","uri":"https://jaylanwood.github.io/tags/%E5%AD%98%E5%82%A8/"},{"title":"对象","uri":"https://jaylanwood.github.io/tags/%E5%AF%B9%E8%B1%A1/"},{"title":"异步","uri":"https://jaylanwood.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"title":"数据库","uri":"https://jaylanwood.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"模块","uri":"https://jaylanwood.github.io/tags/%E6%A8%A1%E5%9D%97/"},{"title":"立即执行函数","uri":"https://jaylanwood.github.io/tags/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/"},{"title":"类","uri":"https://jaylanwood.github.io/tags/%E7%B1%BB/"},{"title":"缓动","uri":"https://jaylanwood.github.io/tags/%E7%BC%93%E5%8A%A8/"},{"title":"解构赋值","uri":"https://jaylanwood.github.io/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"请求","uri":"https://jaylanwood.github.io/tags/%E8%AF%B7%E6%B1%82/"},{"title":"转载文章","uri":"https://jaylanwood.github.io/tags/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"},{"title":"轮播","uri":"https://jaylanwood.github.io/tags/%E8%BD%AE%E6%92%AD/"},{"title":"闭包","uri":"https://jaylanwood.github.io/tags/%E9%97%AD%E5%8C%85/"}]}